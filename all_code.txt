===== main.py =====
#!/usr/bin/env python3
"""
Hockey Editor - –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –≤–∏–¥–µ–æ–º–æ–Ω—Ç–∞–∂–µ—Ä –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ö–æ–∫–∫–µ–π–Ω—ã—Ö –º–∞—Ç—á–µ–π.
–ó–∞–ø—É—Å–∫: python -m hockey_editor.main
"""

import sys
import os

# –î–æ–±–∞–≤–∏—Ç—å –∫–æ—Ä–Ω–µ–≤—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –≤ Python path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from PySide6.QtWidgets import QApplication, QMessageBox
from PySide6.QtCore import Qt

# –ò–º–ø–æ—Ä—Ç—ã –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
from hockey_editor.core.video_controller import VideoController
from hockey_editor.ui.main_window import MainWindow


def main():
    app = QApplication(sys.argv)
    
    # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞–ª–∏—á–∏–µ —Ñ–∞–π–ª–æ–≤ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
    from hockey_editor.utils.autosave import AutosaveManager
    recovery_path = AutosaveManager.check_recovery()
    
    # –°–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä –≤–∏–¥–µ–æ
    controller = VideoController()
    
    # –°–æ–∑–¥–∞—Ç—å –≥–ª–∞–≤–Ω–æ–µ –æ–∫–Ω–æ
    window = MainWindow(controller)
    
    # –ü–æ–∫–∞–∑–∞—Ç—å –æ–∫–Ω–æ
    window.show()
    
    # –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –µ—Å–ª–∏ –µ—Å—Ç—å —Ñ–∞–π–ª
    if recovery_path:
        reply = QMessageBox.question(
            window, "Recovery",
            f"Previous session crashed. Recover project?\n\n{recovery_path}",
            QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel
        )
        
        if reply == QMessageBox.Yes:
            if controller.load_project(recovery_path):
                QMessageBox.information(window, "Success", "Project recovered")
            else:
                QMessageBox.critical(window, "Error", "Failed to recover project")
        elif reply == QMessageBox.No:
            AutosaveManager.clear_recovery()
    
    sys.exit(app.exec())


if __name__ == "__main__":
    main()





===== event_creation_controller.py =====
"""Event creation controller —Å –≥–æ—Ä—è—á–∏–º–∏ –∫–ª–∞–≤–∏—à–∞–º–∏."""

from enum import Enum
from dataclasses import dataclass
from typing import Callable, Optional
from PySide6.QtCore import QTimer, Signal, QObject

from models.marker import Marker, EventType


class EventCreationMode(Enum):
    MANUAL = "manual"
    FIXED_DURATION = "fixed_duration"


class RecordingState(Enum):
    IDLE = "idle"
    RECORDING = "recording"
    RECORDED = "recorded"


@dataclass
class EventCreationConfig:
    mode: EventCreationMode = EventCreationMode.MANUAL
    fixed_duration_ms: int = 5000
    pre_roll_ms: int = 3000
    post_roll_ms: int = 0
    click_sound_enabled: bool = True


class EventCreationController(QObject):
    """–£–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–∑–¥–∞–Ω–∏–µ–º —Å–æ–±—ã—Ç–∏–π —á–µ—Ä–µ–∑ –≥–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏."""

    recording_started = Signal(object, int)
    recording_updated = Signal(object, int)
    recording_finished = Signal(object)
    state_changed = Signal(object)

    def __init__(self, config: Optional[EventCreationConfig] = None):
        super().__init__()
        self.config = config or EventCreationConfig()
        self.state = RecordingState.IDLE
        self.current_event_type: Optional[EventType] = None
        self.recording_start_frame: Optional[int] = None
        self.recording_start_frame_with_preroll: Optional[int] = None
        
        self.get_current_frame: Optional[Callable[[], int]] = None
        self.get_frame_rate: Optional[Callable[[], float]] = None
        self.set_seek_frame: Optional[Callable[[int], None]] = None

    def set_video_controller(self, get_current_frame: Callable[[], int],
                             get_frame_rate: Callable[[], float],
                             set_seek_frame: Callable[[int], None]):
        self.get_current_frame = get_current_frame
        self.get_frame_rate = get_frame_rate
        self.set_seek_frame = set_seek_frame

    def on_hotkey_pressed(self, event_type: EventType) -> bool:
        if self.state == RecordingState.IDLE:
            self._start_recording(event_type)
            return True
        elif self.state == RecordingState.RECORDING and self.current_event_type == event_type:
            self._finish_recording()
            return True
        return False

    def _start_recording(self, event_type: EventType):
        current_frame = self.get_current_frame() if self.get_current_frame else 0
        self.current_event_type = event_type
        self.recording_start_frame = current_frame
        
        frame_rate = self.get_frame_rate() if self.get_frame_rate else 30.0
        pre_roll_frames = int(self.config.pre_roll_ms / 1000.0 * frame_rate)
        self.recording_start_frame_with_preroll = max(0, current_frame - pre_roll_frames)
        
        self.state = RecordingState.RECORDING
        self.state_changed.emit(self.state)
        self.recording_started.emit(event_type, current_frame)

    def _finish_recording(self):
        if not self.get_current_frame or not self.current_event_type:
            return

        current_frame = self.get_current_frame()
        frame_rate = self.get_frame_rate() if self.get_frame_rate else 30.0
        
        post_roll_frames = int(self.config.post_roll_ms / 1000.0 * frame_rate)
        end_frame = current_frame + post_roll_frames
        
        marker = Marker(
            start_frame=self.recording_start_frame_with_preroll,
            end_frame=end_frame,
            type=self.current_event_type,
            note=""
        )
        
        if self.set_seek_frame and self.recording_start_frame_with_preroll is not None:
            self.set_seek_frame(self.recording_start_frame_with_preroll)
        
        self.state = RecordingState.RECORDED
        self.state_changed.emit(self.state)
        self.recording_finished.emit(marker)
        
        QTimer.singleShot(500, lambda: self._reset_state())

    def _reset_state(self):
        self.state = RecordingState.IDLE
        self.current_event_type = None
        self.recording_start_frame = None
        self.recording_start_frame_with_preroll = None
        self.state_changed.emit(self.state)

    def update_recording_frame(self, current_frame: int):
        if self.state == RecordingState.RECORDING:
            self.recording_updated.emit(self.current_event_type, current_frame)

    def cancel_recording(self):
        if self.state == RecordingState.RECORDING:
            self._reset_state()


===== exporter.py =====
from moviepy import VideoFileClip, concatenate_videoclips
from typing import List
from ..models.marker import Marker

class VideoExporter:
    @staticmethod
    def export(video_path: str, markers: List[Marker], total_frames: int, fps: float, output_path: str):
        video = VideoFileClip(video_path)
        clips = []
        markers_with_end = markers + [Marker(frame=total_frames, type=None)]
        
        for i in range(len(markers)):
            start_sec = markers[i].frame / fps
            end_sec = markers_with_end[i + 1].frame / fps
            clip = video.subclip(start_sec, end_sec)
            clips.append(clip)
        
        final = concatenate_videoclips(clips)
        final.write_videofile(output_path, codec="libx264", audio_codec="aac", threads=4)
        video.close()


===== project_manager.py =====
"""
Project Manager - —Å–∏—Å—Ç–µ–º–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è/–∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–µ–∫—Ç–æ–≤ (.hep —Ñ–∞–π–ª—ã).
"""

import json
import zipfile
import os
from pathlib import Path
from typing import List, Optional, Dict
from datetime import datetime
from ..models.marker import Marker, EventType


class Project:
    """–ú–æ–¥–µ–ª—å –ø—Ä–æ–µ–∫—Ç–∞ Hockey Editor Pro."""
    
    def __init__(self, name: str, video_path: str = "", fps: float = 30.0):
        self.name = name
        self.video_path = video_path
        self.fps = fps
        self.markers: List[Marker] = []
        self.created_at = datetime.now().isoformat()
        self.modified_at = datetime.now().isoformat()
        self.version = "1.0"
    
    def to_dict(self) -> Dict:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–µ–∫—Ç –≤ —Å–ª–æ–≤–∞—Ä—å."""
        return {
            "name": self.name,
            "video_path": self.video_path,
            "fps": self.fps,
            "version": self.version,
            "created_at": self.created_at,
            "modified_at": self.modified_at,
            "markers": [
                {
                    "event_name": marker.event_name,
                    "start_frame": marker.start_frame,
                    "end_frame": marker.end_frame,
                    "note": marker.note or ""
                }
                for marker in self.markers
            ]
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Project':
        """–°–æ–∑–¥–∞—Ç—å –ø—Ä–æ–µ–∫—Ç –∏–∑ —Å–ª–æ–≤–∞—Ä—è."""
        project = cls(data["name"], data.get("video_path", ""), data.get("fps", 30.0))
        project.created_at = data.get("created_at", project.created_at)
        project.modified_at = data.get("modified_at", project.modified_at)
        project.version = data.get("version", "1.0")
        
        # –ó–∞–≥—Ä—É–∑–∏—Ç—å –º–∞—Ä–∫–µ—Ä—ã
        for marker_data in data.get("markers", []):
            marker = Marker(
                event_name=marker_data["event_name"],
                start_frame=marker_data["start_frame"],
                end_frame=marker_data["end_frame"],
                note=marker_data.get("note", "")
            )
            project.markers.append(marker)
        
        return project


class ProjectManager:
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞–º–∏ (.hep —Ñ–∞–π–ª—ã = ZIP —Å project.json)."""
    
    HEP_VERSION = "1.0"
    MANIFEST_FILE = "project.json"
    
    @staticmethod
    def create_project(name: str, video_path: str = "", fps: float = 30.0) -> Project:
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç."""
        return Project(name, video_path, fps)
    
    @staticmethod
    def save_project(project: Project, file_path: str) -> bool:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–µ–∫—Ç –≤ .hep —Ñ–∞–π–ª."""
        try:
            file_path = Path(file_path)
            
            # –£–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –ø—É—Ç—å –∏–º–µ–µ—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ .hep
            if file_path.suffix.lower() != ".hep":
                file_path = file_path.with_suffix(".hep")
            
            # –û–±–Ω–æ–≤–∏—Ç—å –≤—Ä–µ–º—è –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏
            project.modified_at = datetime.now().isoformat()
            
            # –°–æ–∑–¥–∞—Ç—å ZIP –∞—Ä—Ö–∏–≤
            with zipfile.ZipFile(file_path, 'w', zipfile.ZIP_DEFLATED) as hep:
                # –ù–∞–ø–∏—Å–∞—Ç—å project.json
                manifest = {
                    "version": ProjectManager.HEP_VERSION,
                    "project": project.to_dict()
                }
                
                hep.writestr(ProjectManager.MANIFEST_FILE, 
                           json.dumps(manifest, indent=2, ensure_ascii=False))
            
            return True
        except Exception as e:
            print(f"Error saving project: {e}")
            return False
    
    @staticmethod
    def load_project(file_path: str) -> Optional[Project]:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ–µ–∫—Ç –∏–∑ .hep —Ñ–∞–π–ª–∞."""
        try:
            file_path = Path(file_path)
            
            if not file_path.exists():
                print(f"Project file not found: {file_path}")
                return None
            
            # –û—Ç–∫—Ä—ã—Ç—å ZIP –∞—Ä—Ö–∏–≤
            with zipfile.ZipFile(file_path, 'r') as hep:
                # –ü—Ä–æ—á–∏—Ç–∞—Ç—å project.json
                manifest_data = hep.read(ProjectManager.MANIFEST_FILE)
                manifest = json.loads(manifest_data)
                
                # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤–µ—Ä—Å–∏—é
                version = manifest.get("version", "1.0")
                if version != ProjectManager.HEP_VERSION:
                    print(f"Warning: Project version {version} may not be compatible")
                
                # –ó–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ–µ–∫—Ç
                project_data = manifest.get("project", {})
                project = Project.from_dict(project_data)
                
                return project
        except Exception as e:
            print(f"Error loading project: {e}")
            return None
    
    @staticmethod
    def get_recent_projects(max_count: int = 5) -> List[str]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –Ω–µ–¥–∞–≤–Ω–∏—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤ –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞."""
        from ..utils.settings_manager import get_settings_manager
        settings = get_settings_manager()
        recent = settings.load_recent_projects()
        return recent[:max_count]
    
    @staticmethod
    def add_to_recent(file_path: str):
        """–î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–µ–∫—Ç –≤ —Å–ø–∏—Å–æ–∫ –Ω–µ–¥–∞–≤–Ω–∏—Ö."""
        from ..utils.settings_manager import get_settings_manager
        settings = get_settings_manager()
        
        recent = settings.load_recent_projects()
        file_path = str(Path(file_path).absolute())
        
        # –£–¥–∞–ª–∏—Ç—å –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å
        if file_path in recent:
            recent.remove(file_path)
        
        # –î–æ–±–∞–≤–∏—Ç—å –≤ –Ω–∞—á–∞–ª–æ
        recent.insert(0, file_path)
        
        # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å (–º–∞–∫—Å 10 –ø—Ä–æ–µ–∫—Ç–æ–≤)
        settings.save_recent_projects(recent[:10])


===== video_controller.py =====
from PySide6.QtCore import QObject, Signal, QTimer
from typing import List, Optional, Dict
from enum import Enum
import json
import os
from .video_processor import VideoProcessor
from ..models.marker import Marker, EventType
from ..utils.settings_manager import get_settings_manager
from ..utils.custom_events import get_custom_event_manager


class RecordingMode(Enum):
    """–†–µ–∂–∏–º—ã —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏ –æ—Ç—Ä–µ–∑–∫–æ–≤."""
    DYNAMIC = "dynamic"          # –î–≤–∞ –Ω–∞–∂–∞—Ç–∏—è = –Ω–∞—á–∞–ª–æ –∏ –∫–æ–Ω–µ—Ü
    FIXED_LENGTH = "fixed_length"  # –û–¥–Ω–æ –Ω–∞–∂–∞—Ç–∏–µ = –æ—Ç—Ä–µ–∑–æ–∫ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã


class VideoController(QObject):
    """–ì–ª–∞–≤–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä –≤–∏–¥–µ–æ —Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–µ–π –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è."""
    
    # –°–∏–≥–Ω–∞–ª—ã
    playback_time_changed = Signal(int)  # frame_idx
    markers_changed = Signal()
    recording_status_changed = Signal(str, str)  # event_type (A/D/S), status (Recording/Complete)
    timeline_update = Signal()
    current_frame_update = Signal(int)  # frame_idx
    frame_ready = Signal(object)  # np.ndarray (—Ç–µ–∫—É—â–∏–π –∫–∞–¥—Ä)

    def __init__(self):
        super().__init__()

        self.processor = VideoProcessor()
        self.markers: List[Marker] = []

        # SettingsManager –¥–ª—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
        self.settings = get_settings_manager()

        # CustomEventManager - –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–±—ã—Ç–∏–π
        self.event_manager = get_custom_event_manager()

        # UndoRedoManager
        from ..utils.undo_redo import UndoRedoManager
        self.undo_redo = UndoRedoManager()

        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
        self.playing = False
        self.playback_timer = QTimer()
        self.playback_timer.timeout.connect(self._on_playback_tick)
        self.frame_time_ms = 33  # ~30 FPS (—Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –Ω–∞ –æ—Å–Ω–æ–≤–µ FPS –≤–∏–¥–µ–æ)

        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏ –æ—Ç—Ä–µ–∑–∫–æ–≤ (–∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑ QSettings)
        mode_str = self.settings.load_recording_mode()
        self.recording_mode = RecordingMode(mode_str)
        self.fixed_duration_sec = self.settings.load_fixed_duration()
        self.pre_roll_sec = self.settings.load_pre_roll()
        self.post_roll_sec = self.settings.load_post_roll()

        # –°–æ—Å—Ç–æ—è–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –∑–∞–ø–∏—Å–∏ (–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ä–µ–∂–∏–º)
        self.is_recording = False
        self.recording_event_name: Optional[str] = None  # –ò–º—è —Å–æ–±—ã—Ç–∏—è –≤–º–µ—Å—Ç–æ EventType
        self.recording_start_frame: Optional[int] = None

    def load_video(self, video_path: str) -> bool:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –≤–∏–¥–µ–æ—Ñ–∞–π–ª (–ü–ê–£–ó–ò–†–û–í–ê–ù!)."""
        success = self.processor.load(video_path)
        if success:
            # –†–∞—Å—Å—á–∏—Ç–∞—Ç—å frame_time_ms –Ω–∞ –æ—Å–Ω–æ–≤–µ FPS –≤–∏–¥–µ–æ
            fps = self.processor.get_fps()
            if fps > 0:
                self.frame_time_ms = int(1000 / fps)
            
            # –£–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –≤–∏–¥–µ–æ –Ω–∞ –ø–∞—É–∑–µ
            self.playing = False
            self.playback_timer.stop()
            
            # –û–±–Ω–æ–≤–∏—Ç—å –º–∞—Ä–∫–µ—Ä—ã –∏ UI
            self.markers = []
            self.markers_changed.emit()
            self.playback_time_changed.emit(0)
            self.current_frame_update.emit(0)
            self.timeline_update.emit()
            
            # –û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–µ—Ä–≤—ã–π –∫–∞–¥—Ä –Ω–∞ UI
            frame = self.processor.get_current_frame()
            if frame is not None:
                self.frame_ready.emit(frame)
        
        return success

    def play(self):
        """–ù–∞—á–∞—Ç—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ."""
        if self.processor.cap is None or self.playing:
            return
        
        self.playing = True
        self.playback_timer.start(self.frame_time_ms)

    def pause(self):
        """–ü–∞—É–∑–∞."""
        self.playing = False
        self.playback_timer.stop()

    def toggle_play_pause(self):
        """–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å Play/Pause."""
        if self.playing:
            self.pause()
        else:
            self.play()

    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏ –≤–æ–∑–≤—Ä–∞—Ç –≤ –Ω–∞—á–∞–ª–æ."""
        self.pause()
        self.seek_frame(0)

    def seek_frame(self, frame_idx: int):
        """–ü–µ—Ä–µ–º–æ—Ç–∞—Ç—å –Ω–∞ –∫–∞–¥—Ä (–ù–ï –∑–∞–ø—É—Å–∫–∞–µ—Ç –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ)."""
        if self.processor.cap is None:
            return
        
        self.processor.seek(frame_idx)
        
        # –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∏–≥–Ω–∞–ª—ã –æ–± –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏
        self.playback_time_changed.emit(frame_idx)
        self.current_frame_update.emit(frame_idx)
        self.timeline_update.emit()
        
        # –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–∞–¥—Ä –Ω–∞ UI
        frame = self.processor.get_current_frame()
        if frame is not None:
            self.frame_ready.emit(frame)

    def _on_playback_tick(self):
        """–¢–∞–π–º–µ—Ä –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è - –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∫–∞–∂–¥—ã–π frame_time_ms."""
        if not self.processor.cap or not self.playing:
            return
        
        # –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å—Å—è –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –∫–∞–¥—Ä
        success = self.processor.advance_frame()
        if not success:
            # –ö–æ–Ω–µ—Ü –≤–∏–¥–µ–æ
            self.pause()
            return
        
        # –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–π –∏–Ω–¥–µ–∫—Å –∫–∞–¥—Ä–∞
        current_frame_idx = self.processor.get_current_frame_idx()
        
        # –≠–º–∏—Ç —Å–∏–≥–Ω–∞–ª–æ–≤ –æ–± –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏
        self.playback_time_changed.emit(current_frame_idx)
        self.current_frame_update.emit(current_frame_idx)
        self.timeline_update.emit()
        
        # –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–∫—É—â–∏–π –∫–∞–¥—Ä –Ω–∞ UI
        frame = self.processor.get_current_frame()
        if frame is not None:
            self.frame_ready.emit(frame)

    def on_hotkey_pressed(self, key: str):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –≥–æ—Ä—è—á–µ–π –∫–ª–∞–≤–∏—à–∏."""
        # –ù–∞–π—Ç–∏ —Å–æ–±—ã—Ç–∏–µ –ø–æ –∫–ª–∞–≤–∏—à–µ
        event = self.event_manager.get_event_by_hotkey(key)
        if not event:
            return  # –ù–µ—Ç —Å–æ–±—ã—Ç–∏—è –¥–ª—è —ç—Ç–æ–π –∫–ª–∞–≤–∏—à–∏

        current_frame = self.processor.get_current_frame_idx()
        event_name = event.name

        if self.recording_mode == RecordingMode.DYNAMIC:
            self._handle_dynamic_mode(event_name, current_frame)
        elif self.recording_mode == RecordingMode.FIXED_LENGTH:
            self._handle_fixed_length_mode(event_name, current_frame)

    def _handle_dynamic_mode(self, event_name: str, current_frame: int):
        """–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ä–µ–∂–∏–º: –¥–≤–∞ –Ω–∞–∂–∞—Ç–∏—è = –Ω–∞—á–∞–ª–æ –∏ –∫–æ–Ω–µ—Ü."""
        if not self.is_recording:
            # –ù–∞—á–∞–ª–æ –∑–∞–ø–∏—Å–∏
            self.is_recording = True
            self.recording_event_name = event_name
            self.recording_start_frame = current_frame
            self.recording_status_changed.emit(event_name, "Recording")
            self.timeline_update.emit()
        elif self.recording_event_name == event_name:
            # –ö–æ–Ω–µ—Ü –∑–∞–ø–∏—Å–∏
            pre_roll_frames = max(0, int(self.pre_roll_sec * self.processor.fps))
            start_frame = max(0, self.recording_start_frame - pre_roll_frames)

            marker = Marker(
                start_frame=start_frame,
                end_frame=current_frame,
                event_name=event_name,
                note=""
            )
            self.markers.append(marker)

            # –ê–≤—Ç–æ–æ—Ç–∫–∞—Ç –Ω–∞—á–∞–ª–∞ –æ—Ç—Ä–µ–∑–∫–∞
            self.seek_frame(start_frame)

            self.is_recording = False
            self.recording_event_name = None
            self.recording_start_frame = None

            self.recording_status_changed.emit(event_name, "Complete")
            self.markers_changed.emit()
            self.timeline_update.emit()

    def _handle_fixed_length_mode(self, event_name: str, current_frame: int):
        """–§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –¥–ª–∏–Ω–∞: –æ–¥–Ω–æ –Ω–∞–∂–∞—Ç–∏–µ = –æ—Ç—Ä–µ–∑–æ–∫ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã."""
        # –†–∞—Å—Å—á–∏—Ç–∞—Ç—å –≥—Ä–∞–Ω–∏—Ü—ã
        fixed_frames = int(self.fixed_duration_sec * self.processor.fps)
        pre_roll_frames = max(0, int(self.pre_roll_sec * self.processor.fps))

        start_frame = max(0, current_frame - pre_roll_frames)
        end_frame = min(self.processor.total_frames - 1, current_frame + fixed_frames - pre_roll_frames)

        # –°–æ–∑–¥–∞—Ç—å –æ—Ç—Ä–µ–∑–æ–∫
        marker = Marker(
            start_frame=start_frame,
            end_frame=end_frame,
            event_name=event_name,
            note=""
        )
        self.markers.append(marker)

        # –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
        self.recording_status_changed.emit(event_name, "Fixed")

        # –ê–≤—Ç–æ–æ—Ç–∫–∞—Ç –Ω–∞—á–∞–ª–∞ –æ—Ç—Ä–µ–∑–∫–∞
        self.seek_frame(start_frame)

        self.markers_changed.emit()
        self.timeline_update.emit()

    def cancel_recording(self):
        """–û—Ç–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é –∑–∞–ø–∏—Å—å."""
        if self.is_recording:
            self.is_recording = False
            self.recording_event_name = None
            self.recording_start_frame = None
            self.recording_status_changed.emit("", "Cancelled")
            self.timeline_update.emit()

    def delete_marker(self, idx: int):
        """–£–¥–∞–ª–∏—Ç—å –æ—Ç—Ä–µ–∑–æ–∫ (—Å undo/redo)."""
        if 0 <= idx < len(self.markers):
            from ..utils.undo_redo import DeleteMarkerCommand
            command = DeleteMarkerCommand(self.markers, idx)
            self.undo_redo.push_command(command)
            self.markers_changed.emit()
            self.timeline_update.emit()

    def clear_markers(self):
        """–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –æ—Ç—Ä–µ–∑–∫–∏ (—Å undo/redo)."""
        from ..utils.undo_redo import ClearMarkersCommand
        command = ClearMarkersCommand(self.markers)
        self.undo_redo.push_command(command)
        self.markers_changed.emit()
        self.timeline_update.emit()

    def set_recording_mode(self, mode: RecordingMode):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ä–µ–∂–∏–º —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏ –æ—Ç—Ä–µ–∑–∫–æ–≤."""
        self.recording_mode = mode
        self.settings.save_recording_mode(mode.value)

    def set_fixed_duration(self, seconds: int):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—É—é –¥–ª–∏–Ω—É –æ—Ç—Ä–µ–∑–∫–∞."""
        self.fixed_duration_sec = seconds
        self.settings.save_fixed_duration(seconds)

    def set_pre_roll(self, seconds: float):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ—Ç–∫–∞—Ç –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –æ—Ç—Ä–µ–∑–∫–∞."""
        self.pre_roll_sec = seconds
        self.settings.save_pre_roll(seconds)

    def set_post_roll(self, seconds: float):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω–µ—Ü –æ—Ç—Ä–µ–∑–∫–∞."""
        self.post_roll_sec = seconds
        self.settings.save_post_roll(seconds)

    # –ú–µ—Ç–æ–¥ update_hotkeys —É–±—Ä–∞–Ω - hotkeys —Ç–µ–ø–µ—Ä—å —É–ø—Ä–∞–≤–ª—è—é—Ç—Å—è —á–µ—Ä–µ–∑ CustomEventManager

    def get_current_frame_idx(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–π –∏–Ω–¥–µ–∫—Å –∫–∞–¥—Ä–∞."""
        return self.processor.get_current_frame_idx()

    def get_fps(self) -> float:
        """–ü–æ–ª—É—á–∏—Ç—å FPS –≤–∏–¥–µ–æ."""
        return self.processor.get_fps()

    def get_total_frames(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–¥—Ä–æ–≤."""
        return self.processor.get_total_frames()

    def cleanup(self):
        """–û—á–∏—Å—Ç–∏—Ç—å —Ä–µ—Å—É—Ä—Å—ã."""
        self.pause()
        self.processor.cleanup()
        self.markers.clear()

    # ===== –ü–†–û–ï–ö–¢–´ =====
    
    def save_project(self, file_path: str) -> bool:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–µ–∫—Ç –≤ —Ñ–∞–π–ª."""
        from .project_manager import ProjectManager, Project
        
        project = Project(
            name=self.processor.filename or "Untitled",
            video_path=self.processor.path,
            fps=self.get_fps()
        )
        project.markers = self.markers.copy()
        
        success = ProjectManager.save_project(project, file_path)
        if success:
            ProjectManager.add_to_recent(file_path)
        return success
    
    def load_project(self, file_path: str) -> bool:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ–µ–∫—Ç –∏–∑ —Ñ–∞–π–ª–∞."""
        from .project_manager import ProjectManager
        
        project = ProjectManager.load_project(file_path)
        if not project:
            return False
        
        # –ó–∞–≥—Ä—É–∑–∏—Ç—å –≤–∏–¥–µ–æ
        if project.video_path and os.path.exists(project.video_path):
            if not self.load_video(project.video_path):
                return False
        
        # –ó–∞–≥—Ä—É–∑–∏—Ç—å –º–∞—Ä–∫–µ—Ä—ã
        self.markers = project.markers.copy()
        self.markers_changed.emit()
        
        ProjectManager.add_to_recent(file_path)
        return True
    
    def get_recent_projects(self) -> List[str]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –Ω–µ–¥–∞–≤–Ω–∏—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤."""
        from .project_manager import ProjectManager
        return ProjectManager.get_recent_projects()
    
    # ===== UNDO/REDO =====
    
    def undo(self):
        """–û—Ç–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –æ–ø–µ—Ä–∞—Ü–∏—é."""
        self.undo_redo.undo()
        self.markers_changed.emit()
    
    def redo(self):
        """–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –æ—Ç–º–µ–Ω—ë–Ω–Ω—É—é –æ–ø–µ—Ä–∞—Ü–∏—é."""
        self.undo_redo.redo()
        self.markers_changed.emit()
    
    def can_undo(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –º–æ–∂–Ω–æ –ª–∏ –æ—Ç–º–µ–Ω–∏—Ç—å."""
        return self.undo_redo.can_undo()
    
    def can_redo(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –º–æ–∂–Ω–æ –ª–∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å."""
        return self.undo_redo.can_redo()


===== video_processor.py =====
import cv2
import numpy as np
from typing import Optional, Tuple
import os


class VideoProcessor:
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∏–¥–µ–æ —á–µ—Ä–µ–∑ OpenCV (cv2.VideoCapture) —Å –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏–µ–π —Ç–µ–∫—É—â–µ–≥–æ –∫–∞–¥—Ä–∞."""

    def __init__(self):
        self.cap: Optional[cv2.VideoCapture] = None
        self.video_path: Optional[str] = None
        self.fps: float = 0.0
        self.total_frames: int = 0
        self.current_frame_idx: int = 0
        self.frame_width: int = 0
        self.frame_height: int = 0
        self._current_frame_buffer: Optional[np.ndarray] = None  # –ë—É—Ñ–µ—Ä —Ç–µ–∫—É—â–µ–≥–æ –∫–∞–¥—Ä–∞

    def load(self, video_path: str) -> bool:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –≤–∏–¥–µ–æ—Ñ–∞–π–ª."""
        if not os.path.exists(video_path):
            return False
        
        # –ó–∞–∫—Ä—ã—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–µ–µ –≤–∏–¥–µ–æ
        self.cleanup()
        
        self.cap = cv2.VideoCapture(video_path)
        if not self.cap.isOpened():
            self.cap = None
            return False
        
        self.video_path = video_path
        self.fps = self.cap.get(cv2.CAP_PROP_FPS)
        self.total_frames = int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT))
        self.frame_width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        self.frame_height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        self.current_frame_idx = 0
        
        # –ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–µ—Ä–≤—ã–π –∫–∞–¥—Ä –≤ –±—É—Ñ–µ—Ä
        self._read_and_buffer_frame()
        
        return True

    def seek(self, frame_idx: int) -> bool:
        """–ü–µ—Ä–µ–º–æ—Ç–∞—Ç—å –Ω–∞ –∫–∞–¥—Ä (–ë–ï–ó –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è)."""
        if not self.cap:
            return False
        
        frame_idx = max(0, min(frame_idx, self.total_frames - 1))
        ret = self.cap.set(cv2.CAP_PROP_POS_FRAMES, frame_idx)
        if ret:
            self.current_frame_idx = frame_idx
            self._read_and_buffer_frame()
        return ret

    def advance_frame(self) -> bool:
        """–ü–µ—Ä–µ–π—Ç–∏ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –∫–∞–¥—Ä (–¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è)."""
        if not self.cap:
            return False
        
        # –ü—Ä–æ—Å—Ç–æ —á–∏—Ç–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π –∫–∞–¥—Ä
        ret, frame = self.cap.read()
        if ret:
            self.current_frame_idx = int(self.cap.get(cv2.CAP_PROP_POS_FRAMES))
            self._current_frame_buffer = frame
            return True
        return False

    def _read_and_buffer_frame(self) -> bool:
        """–ü—Ä–æ—á–∏—Ç–∞—Ç—å –∫–∞–¥—Ä —Å —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏ –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –±—É—Ñ–µ—Ä."""
        if not self.cap:
            return False
        
        ret, frame = self.cap.read()
        if ret:
            self._current_frame_buffer = frame
            return True
        return False

    def get_current_frame(self) -> Optional[np.ndarray]:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–π –∫–∞–¥—Ä –∏–∑ –±—É—Ñ–µ—Ä–∞ (–ë–ï–ó —á—Ç–µ–Ω–∏—è)."""
        return self._current_frame_buffer

    def get_frame_at(self, frame_idx: int) -> Optional[np.ndarray]:
        """–ü–æ–ª—É—á–∏—Ç—å –∫–∞–¥—Ä –ø–æ –∏–Ω–¥–µ–∫—Å—É (–≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥)."""
        if not self.cap:
            return None
        
        self.seek(frame_idx)
        return self.get_current_frame()

    def get_current_time(self) -> float:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è (—Å–µ–∫—É–Ω–¥—ã)."""
        if self.fps == 0:
            return 0.0
        return self.current_frame_idx / self.fps

    def get_fps(self) -> float:
        """–ü–æ–ª—É—á–∏—Ç—å FPS –≤–∏–¥–µ–æ."""
        return self.fps

    def get_total_frames(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–¥—Ä–æ–≤."""
        return self.total_frames

    def get_total_time(self) -> float:
        """–ü–æ–ª—É—á–∏—Ç—å –æ–±—â—É—é –¥–ª–∏–Ω—É –≤–∏–¥–µ–æ (—Å–µ–∫—É–Ω–¥—ã)."""
        if self.fps == 0:
            return 0.0
        return self.total_frames / self.fps

    def get_current_frame_idx(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å –∏–Ω–¥–µ–∫—Å —Ç–µ–∫—É—â–µ–≥–æ –∫–∞–¥—Ä–∞."""
        return self.current_frame_idx

    def get_resolution(self) -> Tuple[int, int]:
        """–ü–æ–ª—É—á–∏—Ç—å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ (width, height)."""
        return self.frame_width, self.frame_height

    def cleanup(self):
        """–ó–∞–∫—Ä—ã—Ç—å –≤–∏–¥–µ–æ—Ñ–∞–π–ª."""
        if self.cap:
            self.cap.release()
            self.cap = None
        self.video_path = None
        self.fps = 0.0
        self.total_frames = 0
        self.current_frame_idx = 0
        self._current_frame_buffer = None

    def __del__(self):
        self.cleanup()



===== video_reader_thread.py =====
"""
VideoReaderThread - –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–µ —á—Ç–µ–Ω–∏–µ –≤–∏–¥–µ–æ–∫–∞–¥—Ä–æ–≤.
–ß–∏—Ç–∞–µ—Ç –∫–∞–¥—Ä—ã –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ, –≥–ª–∞–≤–Ω—ã–π –ø–æ—Ç–æ–∫ —Å–≤–æ–±–æ–¥–µ–Ω –¥–ª—è UI.
"""

import cv2
import numpy as np
from queue import Queue, Empty
from typing import Optional
from PySide6.QtCore import QThread, Signal


class VideoReaderThread(QThread):
    """
    –ü–æ—Ç–æ–∫ –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è –≤–∏–¥–µ–æ–∫–∞–¥—Ä–æ–≤.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –æ—á–µ—Ä–µ–¥—å –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –∫–∞–¥—Ä–æ–≤ –≤ –≥–ª–∞–≤–Ω—ã–π –ø–æ—Ç–æ–∫.
    """
    
    # –°–∏–≥–Ω–∞–ª—ã
    frame_decoded = Signal(int, object)  # frame_number, np.ndarray
    error_occurred = Signal(str)          # error_message
    stopped = Signal()                    # –ø–æ—Ç–æ–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
    
    def __init__(self, video_path: str, fps: float, queue_size: int = 5):
        super().__init__()
        self.video_path = video_path
        self.fps = fps
        self.queue_size = queue_size
        self.frame_queue = Queue(maxsize=queue_size)
        
        self.is_running = False
        self.is_paused = False
        self.target_frame = None  # –ï—Å–ª–∏ –Ω–µ None, –ø–µ—Ä–µ–º–æ—Ç–∞—Ç—å –Ω–∞ —ç—Ç–æ—Ç –∫–∞–¥—Ä
        
        self.cap: Optional[cv2.VideoCapture] = None
        self.current_frame_number = 0

    def run(self):
        """–ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª –ø–æ—Ç–æ–∫–∞: —á–∏—Ç–∞–µ—Ç –∏ –∫–ª–∞–¥—ë—Ç –∫–∞–¥—Ä—ã –≤ –æ—á–µ—Ä–µ–¥—å."""
        try:
            self.cap = cv2.VideoCapture(self.video_path)
            if not self.cap.isOpened():
                self.error_occurred.emit(f"Cannot open video: {self.video_path}")
                return
            
            self.is_running = True
            frame_delay = int(1000 / self.fps) if self.fps > 0 else 33  # –º—Å
            
            while self.is_running:
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–µ—Ä–µ–º–æ—Ç–∫—É (seek)
                if self.target_frame is not None:
                    self.cap.set(cv2.CAP_PROP_POS_FRAMES, self.target_frame)
                    self.current_frame_number = self.target_frame
                    self.target_frame = None
                
                # –ï—Å–ª–∏ –ø–∞—É–∑–∏—Ä–æ–≤–∞–Ω, —Å–ø–∞—Ç—å
                if self.is_paused:
                    self.msleep(100)
                    continue
                
                # –ß–∏—Ç–∞—Ç—å –∫–∞–¥—Ä
                ret, frame = self.cap.read()
                if ret:
                    try:
                        self.frame_queue.put_nowait((self.current_frame_number, frame))
                        self.frame_decoded.emit(self.current_frame_number, frame)
                        self.current_frame_number += 1
                    except:
                        pass  # –û—á–µ—Ä–µ–¥—å –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∞, –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –∫–∞–¥—Ä
                    
                    self.msleep(frame_delay)
                else:
                    # –ö–æ–Ω–µ—Ü –≤–∏–¥–µ–æ
                    self.is_running = False
        
        except Exception as e:
            self.error_occurred.emit(str(e))
        
        finally:
            if self.cap:
                self.cap.release()
            self.stopped.emit()

    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ—Ç–æ–∫."""
        self.is_running = False
        self.wait()

    def pause(self):
        """–ü–∞—É–∑–∞ (–ø–æ—Ç–æ–∫ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å, –Ω–æ –Ω–µ —á–∏—Ç–∞–µ—Ç –∫–∞–¥—Ä—ã)."""
        self.is_paused = True

    def resume(self):
        """–í–æ–∑–æ–±–Ω–æ–≤–∏—Ç—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ."""
        self.is_paused = False

    def seek(self, frame_number: int):
        """–ü–µ—Ä–µ–º–æ—Ç–∞—Ç—å –Ω–∞ –∫–∞–¥—Ä (–≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è –≤ —Å–ª–µ–¥—É—é—â–µ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ —Ü–∏–∫–ª–∞)."""
        self.target_frame = frame_number

    def clear_queue(self):
        """–û—á–∏—Å—Ç–∏—Ç—å –æ—á–µ—Ä–µ–¥—å –∫–∞–¥—Ä–æ–≤."""
        try:
            while not self.frame_queue.empty():
                self.frame_queue.get_nowait()
        except Empty:
            pass


===== marker.py =====
from dataclasses import dataclass
from enum import Enum

class EventType(Enum):
    """–£—Å—Ç–∞—Ä–µ–≤—à–∏–π enum - –¥–ª—è backwards compatibility."""
    ATTACK = "–ê—Ç–∞–∫–∞"
    DEFENSE = "–ó–∞—â–∏—Ç–∞"
    SHIFT = "–°–º–µ–Ω–∞"

@dataclass
class Marker:
    start_frame: int
    end_frame: int
    event_name: str  # –ù–æ–≤–æ–µ –ø–æ–ª–µ: –∏–º—è —Å–æ–±—ã—Ç–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, "Attack", "Defense", "MyCustomEvent")
    note: str = ""

    def to_dict(self):
        return {
            "start_frame": self.start_frame,
            "end_frame": self.end_frame,
            "event_name": self.event_name,  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–º—è —Å–æ–±—ã—Ç–∏—è
            "note": self.note
        }

    @classmethod
    def from_dict(cls, data):
        # Backwards compatibility: –µ—Å–ª–∏ –µ—Å—Ç—å –ø–æ–ª–µ "type" –≤–º–µ—Å—Ç–æ "event_name"
        if "type" in data and "event_name" not in data:
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–∞—Ä—ã–π enum value –≤ –∏–º—è —Å–æ–±—ã—Ç–∏—è
            event_type_value = data["type"]
            # –ú–∞–ø–ø–∏–Ω–≥ —Å—Ç–∞—Ä—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –Ω–∞ –∏–º–µ–Ω–∞
            type_to_name = {
                "–ê—Ç–∞–∫–∞": "Attack",
                "–ó–∞—â–∏—Ç–∞": "Defense",
                "–°–º–µ–Ω–∞": "Shift"
            }
            event_name = type_to_name.get(event_type_value, event_type_value)
        else:
            event_name = data.get("event_name", "Attack")  # Default to Attack

        return cls(
            start_frame=data["start_frame"],
            end_frame=data["end_frame"],
            event_name=event_name,
            note=data.get("note", "")
        )


===== custom_event_dialog.py =====
"""
Dialog for managing custom event types with add/edit/delete functionality.
"""

from typing import Optional
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem,
    QPushButton, QMessageBox, QInputDialog, QColorDialog, QFormLayout,
    QLineEdit, QLabel, QGroupBox
)
from PySide6.QtGui import QColor, QIcon, QPixmap
from PySide6.QtCore import Qt

from hockey_editor.utils.custom_events import CustomEventManager, CustomEventType, get_custom_event_manager


class CustomEventDialog(QDialog):
    """Dialog for adding/editing custom event types."""

    def __init__(self, parent=None, event: Optional[CustomEventType] = None):
        """Initialize event dialog.
        
        Args:
            parent: Parent widget
            event: If provided, dialog is in edit mode for this event
        """
        super().__init__(parent)
        self._event = event  # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –∏–º—è –∞—Ç—Ä–∏–±—É—Ç–∞
        self.is_edit_mode = event is not None
        self.selected_color = QColor(event.color) if event else QColor('#CCCCCC')
        
        self.setWindowTitle('Edit Event Type' if self.is_edit_mode else 'Add Event Type')
        self.setModal(True)
        self.setMinimumWidth(400)
        
        self._create_ui()
        self._load_data()
    
    def _create_ui(self) -> None:
        """Create dialog UI."""
        layout = QVBoxLayout()
        
        # Form layout for fields
        form = QFormLayout()
        
        # Name field
        self.name_input = QLineEdit()
        self.name_input.setPlaceholderText('e.g., Attack, Goal, Penalty')
        form.addRow('Event Name:', self.name_input)
        
        # Description field
        self.desc_input = QLineEdit()
        self.desc_input.setPlaceholderText('e.g., Offensive play')
        form.addRow('Description:', self.desc_input)
        
        # Shortcut field
        self.shortcut_input = QLineEdit()
        self.shortcut_input.setPlaceholderText('e.g., A, Ctrl+X, Shift+1')
        form.addRow('Shortcut:', self.shortcut_input)
        
        layout.addLayout(form)
        
        # Color picker
        color_group = QGroupBox('Color')
        color_layout = QHBoxLayout()
        
        self.color_label = QLabel()
        self.color_label.setFixedSize(40, 40)
        self.color_label.setStyleSheet('border: 1px solid #333;')
        self._update_color_label()
        
        color_btn = QPushButton('Choose Color...')
        color_btn.clicked.connect(self._on_choose_color)
        
        color_layout.addWidget(self.color_label)
        color_layout.addWidget(color_btn)
        color_layout.addStretch()
        color_group.setLayout(color_layout)
        
        layout.addWidget(color_group)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        ok_btn = QPushButton('OK')
        ok_btn.clicked.connect(self.accept)
        
        cancel_btn = QPushButton('Cancel')
        cancel_btn.clicked.connect(self.reject)
        
        button_layout.addStretch()
        button_layout.addWidget(ok_btn)
        button_layout.addWidget(cancel_btn)
        
        layout.addLayout(button_layout)
        
        self.setLayout(layout)
    
    def _load_data(self) -> None:
        """Load existing event data if in edit mode."""
        if self.is_edit_mode and self._event:
            self.name_input.setText(self._event.name)
            self.desc_input.setText(self._event.description)
            self.shortcut_input.setText(self._event.shortcut)
            self.selected_color = QColor(self._event.color)
            self._update_color_label()
            # Disable name editing in edit mode
            self.name_input.setReadOnly(True)
    
    def _on_choose_color(self) -> None:
        """Open color picker dialog."""
        color = QColorDialog.getColor(self.selected_color, self, 'Choose Event Color')
        if color.isValid():
            self.selected_color = color
            self._update_color_label()
    
    def _update_color_label(self) -> None:
        """Update color preview label."""
        self.color_label.setStyleSheet(
            f'background-color: {self.selected_color.name()}; border: 1px solid #333;'
        )
    
    def get_event(self) -> CustomEventType:
        """Get the resulting event object."""
        return CustomEventType(
            name=self.name_input.text().strip(),
            color=self.selected_color.name(),
            shortcut=self.shortcut_input.text().strip(),
            description=self.desc_input.text().strip()
        )


class CustomEventManagerDialog(QDialog):
    """Main dialog for managing all custom event types."""
    
    def __init__(self, parent=None):
        """Initialize manager dialog."""
        super().__init__(parent)
        self.manager: CustomEventManager = get_custom_event_manager()
        
        self.setWindowTitle('Manage Event Types')
        self.setModal(True)
        self.setMinimumSize(500, 400)
        
        self._create_ui()
        self._refresh_list()
    
    def _create_ui(self) -> None:
        """Create dialog UI."""
        layout = QVBoxLayout()
        
        # Event list
        list_label = QLabel('Event Types:')
        layout.addWidget(list_label)
        
        self.event_list = QListWidget()
        self.event_list.itemSelectionChanged.connect(self._on_selection_changed)
        self.event_list.itemDoubleClicked.connect(self._on_edit_event)
        layout.addWidget(self.event_list)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        self.add_btn = QPushButton('‚ûï Add Event')
        self.add_btn.clicked.connect(self._on_add_event)
        button_layout.addWidget(self.add_btn)
        
        self.edit_btn = QPushButton('‚úèÔ∏è Edit')
        self.edit_btn.clicked.connect(self._on_edit_event)
        self.edit_btn.setEnabled(False)
        button_layout.addWidget(self.edit_btn)
        
        self.delete_btn = QPushButton('üóëÔ∏è Delete')
        self.delete_btn.clicked.connect(self._on_delete_event)
        self.delete_btn.setEnabled(False)
        button_layout.addWidget(self.delete_btn)
        
        button_layout.addStretch()
        
        reset_btn = QPushButton('‚Ü∫ Reset to Defaults')
        reset_btn.clicked.connect(self._on_reset)
        button_layout.addWidget(reset_btn)
        
        layout.addLayout(button_layout)
        
        # Dialog buttons
        dialog_buttons = QHBoxLayout()
        
        close_btn = QPushButton('Close')
        close_btn.clicked.connect(self.accept)
        
        dialog_buttons.addStretch()
        dialog_buttons.addWidget(close_btn)
        
        layout.addLayout(dialog_buttons)
        
        self.setLayout(layout)
    
    def _refresh_list(self) -> None:
        """Refresh event list display."""
        self.event_list.clear()
        
        for event in self.manager.get_all_events():
            # Create list item with color preview and name
            item = QListWidgetItem()
            
            # Create colored pixmap
            pixmap = QPixmap(20, 20)
            pixmap.fill(event.get_qcolor())
            icon = QIcon(pixmap)
            
            # Format display text
            text = f"{event.name}"
            if event.shortcut:
                text += f" [{event.shortcut}]"
            if event.description:
                text += f" - {event.description}"
            
            item.setIcon(icon)
            item.setText(text)
            item.setData(Qt.UserRole, event.name)  # Store event name for lookup
            
            self.event_list.addItem(item)
    
    def _on_selection_changed(self) -> None:
        """Handle event selection change."""
        selected = self.event_list.selectedItems()
        has_selection = len(selected) > 0
        
        self.edit_btn.setEnabled(has_selection)
        
        # Can only delete non-default events
        if has_selection:
            event_name = selected[0].data(Qt.UserRole)
            event = self.manager.get_event(event_name)
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ None
            if event is None:
                self.delete_btn.setEnabled(False)
                return
            
            is_default = event.name in {e.name for e in self.manager.DEFAULT_EVENTS}
            self.delete_btn.setEnabled(has_selection and not is_default)
        else:
            self.delete_btn.setEnabled(False)
    
    def _on_add_event(self) -> None:
        """Handle add event button."""
        dialog = CustomEventDialog(self)
        if dialog.exec() == QDialog.Accepted:
            event = dialog.get_event()
            # Validate
            if not event.name:
                QMessageBox.warning(self, 'Invalid', 'Event name cannot be empty')
                return

            if not self.manager.add_event(event):
                QMessageBox.warning(self, 'Error', f'Event "{event.name}" already exists or has invalid color')
                return

            self._refresh_list()
            QMessageBox.information(self, 'Success', f'Event "{event.name}" added')
    
    def _on_edit_event(self) -> None:
        """Handle edit event button."""
        selected = self.event_list.selectedItems()
        if not selected:
            return
        
        event_name = selected[0].data(Qt.UserRole)
        event = self.manager.get_event(event_name)
        if not event:
            return
        
        dialog = CustomEventDialog(self, event)
        if dialog.exec() == QDialog.Accepted:
            new_event = dialog.get_event()
            if not self.manager.update_event(event_name, new_event):
                QMessageBox.warning(self, 'Error', f'Failed to update event')
                return
            
            self._refresh_list()
            QMessageBox.information(self, 'Success', 'Event updated')
    
    def _on_delete_event(self) -> None:
        """Handle delete event button."""
        selected = self.event_list.selectedItems()
        if not selected:
            return
        
        event_name = selected[0].data(Qt.UserRole)
        
        reply = QMessageBox.question(
            self,
            'Confirm Delete',
            f'Delete event "{event_name}"?\n\nThis cannot be undone.',
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            if self.manager.delete_event(event_name):
                self._refresh_list()
                QMessageBox.information(self, 'Success', f'Event "{event_name}" deleted')
            else:
                QMessageBox.warning(self, 'Error', f'Cannot delete default event "{event_name}"')
    
    def _on_reset(self) -> None:
        """Handle reset to defaults button."""
        reply = QMessageBox.question(
            self,
            'Confirm Reset',
            'Reset all events to defaults?\n\nThis will remove all custom events.',
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.manager.reset_to_defaults()
            self._refresh_list()
            QMessageBox.information(self, 'Success', 'Events reset to defaults')


===== edit_segment_dialog.py =====
"""
–î–∏–∞–ª–æ–≥ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç—Ä–µ–∑–∫–∞ (PySide6).
"""

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QSpinBox, QPushButton,
    QComboBox, QLineEdit
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QFont
from ..models.marker import Marker
from ..utils.custom_events import get_custom_event_manager
from ..utils.time_utils import format_time


class EditSegmentDialog(QDialog):
    """–î–∏–∞–ª–æ–≥ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç—Ä–µ–∑–∫–∞ (–º–∞—Ä–∫–µ—Ä–∞)."""

    def __init__(self, marker: Marker, fps: float, parent=None):
        super().__init__(parent)
        self.marker = marker
        self.fps = fps or 30.0
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å event_name –≤–º–µ—Å—Ç–æ type.name
        self.setWindowTitle(f"Edit Segment - {marker.event_name}")
        self.setModal(True)
        self.resize(500, 300)
        self.setStyleSheet(self._get_dark_stylesheet())

        self._setup_ui()

    def _setup_ui(self):
        """–°–æ–∑–¥–∞—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å."""
        layout = QVBoxLayout(self)
        layout.setSpacing(10)

        # –¢–∏–ø —Å–æ–±—ã—Ç–∏—è
        type_layout = QHBoxLayout()
        type_layout.addWidget(QLabel("Event Type:"))
        self.type_combo = QComboBox()
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å CustomEventManager –≤–º–µ—Å—Ç–æ EventType enum
        self.event_manager = get_custom_event_manager()
        events = self.event_manager.get_all_events()
        for event in events:
            self.type_combo.addItem(event.name, event.name)
        # –ù–∞–π—Ç–∏ —Ç–µ–∫—É—â–∏–π event_name
        current_index = 0
        for i, event in enumerate(events):
            if event.name == self.marker.event_name:
                current_index = i
                break
        self.type_combo.setCurrentIndex(current_index)
        type_layout.addWidget(self.type_combo)
        type_layout.addStretch()
        layout.addLayout(type_layout)
        
        # –ù–∞—á–∞–ª–æ –æ—Ç—Ä–µ–∑–∫–∞
        start_layout = QHBoxLayout()
        start_layout.addWidget(QLabel("Start Frame:"))
        self.start_frame_box = QSpinBox()
        self.start_frame_box.setMinimum(0)
        self.start_frame_box.setMaximum(1000000)
        self.start_frame_box.setValue(self.marker.start_frame)
        self.start_frame_box.valueChanged.connect(self._update_start_time_display)
        start_layout.addWidget(self.start_frame_box)
        
        self.start_time_display = QLabel(self._format_frame_time(self.marker.start_frame))
        self.start_time_display.setMinimumWidth(80)
        start_layout.addWidget(self.start_time_display)
        start_layout.addStretch()
        layout.addLayout(start_layout)
        
        # –ö–æ–Ω–µ—Ü –æ—Ç—Ä–µ–∑–∫–∞
        end_layout = QHBoxLayout()
        end_layout.addWidget(QLabel("End Frame:"))
        self.end_frame_box = QSpinBox()
        self.end_frame_box.setMinimum(0)
        self.end_frame_box.setMaximum(1000000)
        self.end_frame_box.setValue(self.marker.end_frame)
        self.end_frame_box.valueChanged.connect(self._update_end_time_display)
        end_layout.addWidget(self.end_frame_box)
        
        self.end_time_display = QLabel(self._format_frame_time(self.marker.end_frame))
        self.end_time_display.setMinimumWidth(80)
        end_layout.addWidget(self.end_time_display)
        end_layout.addStretch()
        layout.addLayout(end_layout)
        
        # –ü—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
        duration_layout = QHBoxLayout()
        duration_layout.addWidget(QLabel("Duration:"))
        self.duration_label = QLabel(self._format_duration())
        self.duration_label.setFont(QFont("Arial", 10, QFont.Weight.Bold))
        self.duration_label.setStyleSheet("color: #ffcc00;")
        duration_layout.addWidget(self.duration_label)
        duration_layout.addStretch()
        layout.addLayout(duration_layout)
        
        # –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ
        note_layout = QHBoxLayout()
        note_layout.addWidget(QLabel("Note:"))
        self.note_edit = QLineEdit()
        self.note_edit.setText(self.marker.note or "")
        note_layout.addWidget(self.note_edit)
        layout.addLayout(note_layout)
        
        layout.addStretch()
        
        # –ö–Ω–æ–ø–∫–∏
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        ok_btn = QPushButton("‚úì Save")
        ok_btn.setMaximumWidth(100)
        ok_btn.clicked.connect(self.accept)
        button_layout.addWidget(ok_btn)
        
        cancel_btn = QPushButton("‚úï Cancel")
        cancel_btn.setMaximumWidth(100)
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)
        
        layout.addLayout(button_layout)

    def _format_frame_time(self, frame_idx: int) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Ä–µ–º—è –∫–∞–¥—Ä–∞ –≤ MM:SS.FF."""
        if self.fps <= 0:
            return "00:00.00"
        
        total_secs = frame_idx / self.fps
        minutes = int(total_secs) // 60
        seconds = int(total_secs) % 60
        frames = frame_idx % int(self.fps)
        return f"{minutes:02d}:{seconds:02d}.{frames:02d}"

    def _format_duration(self) -> str:
        """–ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ—Ç—Ä–µ–∑–∫–∞."""
        duration_frames = self.end_frame_box.value() - self.start_frame_box.value()
        if self.fps <= 0:
            return "00:00"
        
        duration_secs = duration_frames / self.fps
        minutes = int(duration_secs) // 60
        seconds = int(duration_secs) % 60
        return f"{minutes:02d}:{seconds:02d} ({duration_frames} frames)"

    def _update_start_time_display(self):
        """–û–±–Ω–æ–≤–∏—Ç—å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏."""
        frame = self.start_frame_box.value()
        self.start_time_display.setText(self._format_frame_time(frame))
        self.duration_label.setText(self._format_duration())

    def _update_end_time_display(self):
        """–û–±–Ω–æ–≤–∏—Ç—å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–æ–Ω–µ—á–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏."""
        frame = self.end_frame_box.value()
        self.end_time_display.setText(self._format_frame_time(frame))
        self.duration_label.setText(self._format_duration())

    def get_marker(self) -> Marker:
        """–ü–æ–ª—É—á–∏—Ç—å –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Ä–∫–µ—Ä."""
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å event_name –≤–º–µ—Å—Ç–æ type
        return Marker(
            start_frame=self.start_frame_box.value(),
            end_frame=self.end_frame_box.value(),
            event_name=self.type_combo.currentData(),
            note=self.note_edit.text()
        )

    def _get_dark_stylesheet(self) -> str:
        """–¢—ë–º–Ω—ã–π —Å—Ç–∏–ª—å –¥–ª—è –¥–∏–∞–ª–æ–≥–∞."""
        return """
        QDialog {
            background-color: #1a1a1a;
            color: #ffffff;
        }
        QLabel {
            color: #ffffff;
        }
        QSpinBox, QLineEdit, QComboBox {
            background-color: #333333;
            color: #ffffff;
            border: 1px solid #555555;
            padding: 4px;
            border-radius: 3px;
        }
        QPushButton {
            background-color: #333333;
            color: white;
            border: 1px solid #555555;
            padding: 5px;
            border-radius: 3px;
        }
        QPushButton:hover {
            background-color: #444444;
        }
        """


===== export_dialog.py =====
"""
Export Dialog - –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –¥–∏–∞–ª–æ–≥ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤–∏–¥–µ–æ —Å –æ–ø—Ü–∏—è–º–∏.
"""

from PySide6.QtCore import Qt, QThread, Signal
from PySide6.QtGui import QFont, QColor
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QComboBox,
    QSpinBox, QCheckBox, QProgressBar, QMessageBox, QFileDialog, QGroupBox,
    QScrollArea, QWidget
)
from typing import Optional, List
from ..models.marker import Marker, EventType
from ..core.exporter import VideoExporter


class ExportWorker(QThread):
    """Worker thread –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤–∏–¥–µ–æ –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ UI."""
    
    progress = Signal(int)  # 0-100
    finished = Signal(bool, str)  # (success, message)
    
    def __init__(self, video_path: str, markers: List[Marker], 
                 output_path: str, fps: float, codec: str, quality: int,
                 resolution: str = "source", include_audio: bool = True,
                 merge_segments: bool = False):
        super().__init__()
        self.video_path = video_path
        self.markers = markers
        self.output_path = output_path
        self.fps = fps
        self.codec = codec
        self.quality = quality
        self.resolution = resolution
        self.include_audio = include_audio
        self.merge_segments = merge_segments
        self.is_cancelled = False

    def run(self):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å —ç–∫—Å–ø–æ—Ä—Ç –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ."""
        try:
            self.progress.emit(0)
            
            # –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—Ä–µ–∑–∫–∏
            for idx, marker in enumerate(self.markers):
                if self.is_cancelled:
                    self.finished.emit(False, "Export cancelled")
                    return
                
                progress = int((idx + 1) / len(self.markers) * 100)
                self.progress.emit(progress)
            
            # –§–∏–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —ç–∫—Å–ø–æ—Ä—Ç
            VideoExporter.export(
                self.video_path,
                self.markers,
                fps=self.fps,
                output_path=self.output_path,
                codec=self.codec,
                quality=self.quality
            )
            
            self.progress.emit(100)
            self.finished.emit(True, f"Export completed: {self.output_path}")
            
        except Exception as e:
            self.finished.emit(False, f"Export failed: {str(e)}")

    def cancel(self):
        """–û—Ç–º–µ–Ω–∏—Ç—å —ç–∫—Å–ø–æ—Ä—Ç."""
        self.is_cancelled = True


class ExportDialog(QDialog):
    """–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –¥–∏–∞–ª–æ–≥ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤–∏–¥–µ–æ."""
    
    def __init__(self, controller, parent=None):
        super().__init__(parent)
        self.controller = controller
        self.export_worker = None
        
        self.setWindowTitle("Export Segments")
        self.setGeometry(200, 200, 700, 650)
        self.setStyleSheet(self._get_dark_stylesheet())
        
        self._setup_ui()

    def _setup_ui(self):
        """–°–æ–∑–¥–∞—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å."""
        layout = QVBoxLayout()
        layout.setSpacing(15)
        
        # ===== –í–´–ë–û–† –û–¢–†–ï–ó–ö–û–í =====
        group = QGroupBox("Segments to Export")
        group_layout = QVBoxLayout()
        
        # –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤—ã–±–æ—Ä–æ–º
        select_btn_layout = QHBoxLayout()
        
        self.select_all_btn = QPushButton("Select All")
        self.select_all_btn.clicked.connect(self._select_all_segments)
        select_btn_layout.addWidget(self.select_all_btn)
        
        self.deselect_all_btn = QPushButton("Deselect All")
        self.deselect_all_btn.clicked.connect(self._deselect_all_segments)
        select_btn_layout.addWidget(self.deselect_all_btn)
        
        select_btn_layout.addStretch()
        group_layout.addLayout(select_btn_layout)
        
        # –°–ø–∏—Å–æ–∫ –æ—Ç—Ä–µ–∑–∫–æ–≤ —Å checkbox
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setMaximumHeight(150)
        
        scroll_widget = QWidget()
        self.segments_layout = QVBoxLayout()
        scroll_widget.setLayout(self.segments_layout)
        scroll_area.setWidget(scroll_widget)
        
        # –°–æ–∑–¥–∞—Ç—å checkbox –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ—Ç—Ä–µ–∑–∫–∞
        self.segment_checkboxes = []
        self._populate_segments()
        
        group_layout.addWidget(scroll_area)
        group.setLayout(group_layout)
        layout.addWidget(group)
        
        # ===== –û–ü–¶–ò–ò –í–ò–î–ï–û =====
        video_group = QGroupBox("Video Options")
        video_layout = QVBoxLayout()
        
        # –ö–æ–¥–µ–∫
        codec_layout = QHBoxLayout()
        codec_layout.addWidget(QLabel("Codec:"))
        self.codec_combo = QComboBox()
        self.codec_combo.addItems(["h264", "h265", "mpeg4", "copy"])
        self.codec_combo.setToolTip("Video codec (h264 recommended)")
        codec_layout.addWidget(self.codec_combo)
        codec_layout.addStretch()
        video_layout.addLayout(codec_layout)
        
        # –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ
        resolution_layout = QHBoxLayout()
        resolution_layout.addWidget(QLabel("Resolution:"))
        self.resolution_combo = QComboBox()
        self.resolution_combo.addItems([
            "Source (Original)",
            "2160p (4K)",
            "1080p (Full HD)",
            "720p (HD)",
            "480p (SD)",
            "360p"
        ])
        self.resolution_combo.setCurrentIndex(0)  # Source by default
        self.resolution_combo.setToolTip("Output video resolution")
        resolution_layout.addWidget(self.resolution_combo)
        resolution_layout.addStretch()
        video_layout.addLayout(resolution_layout)
        
        # –ö–∞—á–µ—Å—Ç–≤–æ / Bitrate
        quality_layout = QHBoxLayout()
        quality_layout.addWidget(QLabel("Quality:"))
        self.quality_combo = QComboBox()
        self.quality_combo.addItems([
            "High (CRF 18)",
            "Medium (CRF 23)",
            "Low (CRF 28)",
            "Custom"
        ])
        self.quality_combo.setCurrentIndex(1)  # Medium by default
        self.quality_combo.currentIndexChanged.connect(self._on_quality_changed)
        self.quality_combo.setToolTip("Video quality (lower CRF = better quality)")
        quality_layout.addWidget(self.quality_combo)
        
        self.quality_spin = QSpinBox()
        self.quality_spin.setMinimum(0)
        self.quality_spin.setMaximum(51)
        self.quality_spin.setValue(23)
        self.quality_spin.setSuffix(" CRF")
        self.quality_spin.setVisible(False)
        self.quality_spin.setToolTip("CRF value (0=best, 51=worst)")
        quality_layout.addWidget(self.quality_spin)
        
        quality_layout.addStretch()
        video_layout.addLayout(quality_layout)
        
        # –§–æ—Ä–º–∞—Ç
        format_layout = QHBoxLayout()
        format_layout.addWidget(QLabel("Format:"))
        self.format_combo = QComboBox()
        self.format_combo.addItems(["MP4 (.mp4)", "MOV (.mov)", "MKV (.mkv)", "WebM (.webm)"])
        self.format_combo.setToolTip("Output file format")
        format_layout.addWidget(self.format_combo)
        format_layout.addStretch()
        video_layout.addLayout(format_layout)
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–ø—Ü–∏–∏
        options_layout = QHBoxLayout()
        
        self.audio_check = QCheckBox("Include Audio")
        self.audio_check.setChecked(True)
        self.audio_check.setToolTip("Include audio from source video")
        options_layout.addWidget(self.audio_check)
        
        self.merge_check = QCheckBox("Merge Segments")
        self.merge_check.setChecked(False)
        self.merge_check.setToolTip("Merge all segments into one video file")
        options_layout.addWidget(self.merge_check)
        
        options_layout.addStretch()
        video_layout.addLayout(options_layout)
        
        video_group.setLayout(video_layout)
        layout.addWidget(video_group)
        
        # ===== –ü–†–û–ì–†–ï–°–° =====
        progress_group = QGroupBox("Export Progress")
        progress_layout = QVBoxLayout()
        
        self.progress_label = QLabel("Ready to export")
        progress_layout.addWidget(self.progress_label)
        
        self.progress_bar = QProgressBar()
        self.progress_bar.setMinimum(0)
        self.progress_bar.setMaximum(100)
        self.progress_bar.setValue(0)
        progress_layout.addWidget(self.progress_bar)
        
        progress_group.setLayout(progress_layout)
        layout.addWidget(progress_group)
        
        # ===== –ö–ù–û–ü–ö–ò =====
        btn_layout = QHBoxLayout()
        
        self.browse_btn = QPushButton("üìÅ Browse Output")
        self.browse_btn.setToolTip("Select output file path")
        self.browse_btn.clicked.connect(self._on_browse_output)
        btn_layout.addWidget(self.browse_btn)
        
        btn_layout.addStretch()
        
        self.export_btn = QPushButton("‚ñ∂ Export")
        self.export_btn.setToolTip("Start export process")
        self.export_btn.setStyleSheet("""
            QPushButton {
                background-color: #2d5016;
                color: white;
                padding: 8px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #3d6b1f;
            }
        """)
        self.export_btn.clicked.connect(self._on_export_clicked)
        btn_layout.addWidget(self.export_btn)
        
        self.cancel_btn = QPushButton("‚úï Cancel")
        self.cancel_btn.setToolTip("Cancel and close dialog")
        self.cancel_btn.clicked.connect(self._on_cancel_clicked)
        btn_layout.addWidget(self.cancel_btn)
        
        layout.addLayout(btn_layout)
        
        self.setLayout(layout)
        self.output_path = None
    
    def _populate_segments(self):
        """–ó–∞–ø–æ–ª–Ω–∏—Ç—å —Å–ø–∏—Å–æ–∫ –æ—Ç—Ä–µ–∑–∫–æ–≤."""
        # –û—á–∏—Å—Ç–∏—Ç—å —Å—Ç–∞—Ä—ã–µ checkbox
        for cb in self.segment_checkboxes:
            cb.setParent(None)
        self.segment_checkboxes.clear()
        
        # –°–æ–∑–¥–∞—Ç—å checkbox –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ—Ç—Ä–µ–∑–∫–∞
        fps = self.controller.get_fps()
        for idx, marker in enumerate(self.controller.markers):
            start_time = self._format_time(marker.start_frame / fps if fps > 0 else 0)
            end_time = self._format_time(marker.end_frame / fps if fps > 0 else 0)
            duration = (marker.end_frame - marker.start_frame) / fps if fps > 0 else 0
            
            text = f"{idx+1}. {marker.event_name} ({start_time}‚Äì{end_time}) [{duration:.1f}s]"
            checkbox = QCheckBox(text)
            checkbox.setChecked(True)
            
            self.segment_checkboxes.append(checkbox)
            self.segments_layout.addWidget(checkbox)
    
    def _select_all_segments(self):
        """–í—ã–±—Ä–∞—Ç—å –≤—Å–µ –æ—Ç—Ä–µ–∑–∫–∏."""
        for cb in self.segment_checkboxes:
            cb.setChecked(True)
    
    def _deselect_all_segments(self):
        """–°–Ω—è—Ç—å –≤—ã–±–æ—Ä —Å–æ –≤—Å–µ—Ö –æ—Ç—Ä–µ–∑–∫–æ–≤."""
        for cb in self.segment_checkboxes:
            cb.setChecked(False)
    
    def _on_quality_changed(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞."""
        quality_text = self.quality_combo.currentText()
        
        if "Custom" in quality_text:
            self.quality_spin.setVisible(True)
        else:
            self.quality_spin.setVisible(False)
            
            if "High" in quality_text:
                self.quality_spin.setValue(18)
            elif "Medium" in quality_text:
                self.quality_spin.setValue(23)
            elif "Low" in quality_text:
                self.quality_spin.setValue(28)
    
    def _get_resolution_value(self) -> str:
        """–ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è."""
        resolution_map = {
            0: "source",
            1: "2160p",
            2: "1080p",
            3: "720p",
            4: "480p",
            5: "360p"
        }
        return resolution_map.get(self.resolution_combo.currentIndex(), "source")
    
    def _format_time(self, seconds: float) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Ä–µ–º—è MM:SS."""
        minutes = int(seconds) // 60
        secs = int(seconds) % 60
        return f"{minutes:02d}:{secs:02d}"

    def _on_browse_output(self):
        """–í—ã–±—Ä–∞—Ç—å –ø—É—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è."""
        format_idx = self.format_combo.currentIndex()
        extensions = [".mp4", ".mov", ".mkv", ".webm"]
        ext = extensions[format_idx] if format_idx < len(extensions) else ".mp4"
        
        path, _ = QFileDialog.getSaveFileName(
            self, "Save Export As", "",
            f"Video Files (*{ext});;All Files (*)"
        )
        
        if path:
            self.output_path = path
            self.progress_label.setText(f"Output: {path}")

    def _on_export_clicked(self):
        """–ù–∞—á–∞—Ç—å —ç–∫—Å–ø–æ—Ä—Ç."""
        # –ü–æ–ª—É—á–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –æ—Ç—Ä–µ–∑–∫–∏
        selected_markers = []
        for idx, cb in enumerate(self.segment_checkboxes):
            if cb.isChecked():
                selected_markers.append(self.controller.markers[idx])
        
        if not selected_markers:
            QMessageBox.warning(self, "No Segments", "Please select at least one segment to export")
            return
        
        if not self.output_path:
            QMessageBox.warning(self, "No Output Path", "Please select output file")
            return
        
        # Disable controls
        self.export_btn.setEnabled(False)
        self.browse_btn.setEnabled(False)
        self.codec_combo.setEnabled(False)
        self.quality_spin.setEnabled(False)
        self.quality_combo.setEnabled(False)
        self.resolution_combo.setEnabled(False)
        self.format_combo.setEnabled(False)
        self.audio_check.setEnabled(False)
        self.merge_check.setEnabled(False)
        
        # –ü–æ–ª—É—á–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —ç–∫—Å–ø–æ—Ä—Ç–∞
        codec = self.codec_combo.currentText()
        crf_value = self.quality_spin.value()
        resolution = self._get_resolution_value()
        include_audio = self.audio_check.isChecked()
        merge_segments = self.merge_check.isChecked()
        
        # –ó–∞–ø—É—Å—Ç–∏—Ç—å —ç–∫—Å–ø–æ—Ä—Ç –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å video_path –≤–º–µ—Å—Ç–æ path
        self.export_worker = ExportWorker(
            self.controller.processor.video_path,
            selected_markers,
            self.output_path,
            self.controller.get_fps(),
            codec,
            crf_value,
            resolution,
            include_audio,
            merge_segments
        )
        
        self.export_worker.progress.connect(self._on_progress_update)
        self.export_worker.finished.connect(self._on_export_finished)
        self.export_worker.start()
        
        self.progress_label.setText("Exporting...")

    def _on_progress_update(self, value: int):
        """–û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å."""
        self.progress_bar.setValue(value)
        self.progress_label.setText(f"Exporting... {value}%")

    def _on_export_finished(self, success: bool, message: str):
        """–≠–∫—Å–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à–∏–ª—Å—è."""
        # Re-enable controls
        self.export_btn.setEnabled(True)
        self.browse_btn.setEnabled(True)
        self.codec_combo.setEnabled(True)
        self.quality_spin.setEnabled(True)
        self.quality_combo.setEnabled(True)
        self.resolution_combo.setEnabled(True)
        self.format_combo.setEnabled(True)
        self.audio_check.setEnabled(True)
        self.merge_check.setEnabled(True)
        
        if success:
            QMessageBox.information(self, "Success", message)
            self.progress_label.setText("Export completed!")
            self.accept()
        else:
            QMessageBox.critical(self, "Export Failed", message)
            self.progress_label.setText("Export failed")
            self.progress_bar.setValue(0)

    def _on_cancel_clicked(self):
        """–û—Ç–º–µ–Ω–∏—Ç—å —ç–∫—Å–ø–æ—Ä—Ç."""
        if self.export_worker and self.export_worker.isRunning():
            self.export_worker.cancel()
            self.export_worker.wait()
        self.reject()

    def _get_dark_stylesheet(self) -> str:
        """–¢—ë–º–Ω—ã–π —Å—Ç–∏–ª—å."""
        return """
        QDialog, QGroupBox {
            background-color: #1a1a1a;
            color: #ffffff;
        }
        QGroupBox {
            border: 1px solid #444444;
            border-radius: 4px;
            margin-top: 8px;
            padding-top: 8px;
        }
        QGroupBox::title {
            subcontrol-origin: margin;
            left: 10px;
            padding: 0 3px 0 3px;
        }
        QLabel {
            color: #ffffff;
        }
        QPushButton {
            background-color: #333333;
            color: white;
            border: 1px solid #555555;
            padding: 6px;
            border-radius: 3px;
        }
        QPushButton:hover {
            background-color: #444444;
        }
        QComboBox {
            background-color: #333333;
            color: #ffffff;
            border: 1px solid #555555;
            padding: 4px;
        }
        QSpinBox {
            background-color: #333333;
            color: #ffffff;
            border: 1px solid #555555;
        }
        QProgressBar {
            background-color: #333333;
            border: 1px solid #555555;
            border-radius: 3px;
            text-align: center;
            color: #ffffff;
        }
        QProgressBar::chunk {
            background-color: #ffcc00;
        }
        QCheckBox {
            color: #ffffff;
        }
        QScrollArea {
            background-color: #2a2a2a;
            border: 1px solid #444444;
        }
        """


===== main_window.py =====
from PySide6.QtCore import Qt, QTimer
from PySide6.QtGui import QPixmap, QImage, QFont, QKeySequence, QShortcut
from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QSlider,
    QLabel, QListWidget, QListWidgetItem, QFileDialog, QComboBox, QSpinBox,
    QMessageBox, QSpinBox
)
import cv2
import numpy as np
from pathlib import Path
from .timeline_graphics import TimelineWidget
from .segment_editor import SegmentEditorDialog
from .settings_dialog import SettingsDialog
from ..models.marker import EventType
from ..utils.settings_manager import get_settings_manager
from ..utils.custom_events import get_custom_event_manager
from ..utils.shortcut_manager import ShortcutManager



class MainWindow(QMainWindow):
    """–ì–ª–∞–≤–Ω–æ–µ –æ–∫–Ω–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è."""

    def __init__(self, controller):
        super().__init__()
        self.controller = controller
        self.settings_manager = get_settings_manager()
        self.event_manager = get_custom_event_manager()
        self.event_manager.setParent(self)  # Ensure proper Qt object ownership
        self.shortcut_manager = ShortcutManager(self)
        
        # –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        from ..utils.autosave import AutosaveManager
        self.autosave_manager = AutosaveManager(controller)
        self.autosave_manager.autosave_completed.connect(self._on_autosave_completed)
        
        self.setWindowTitle("Hockey Editor Pro - Professional Video Analysis")
        self.setGeometry(0, 0, 1800, 1000)
        self.setStyleSheet(self._get_dark_stylesheet())
        
        # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ drag-drop –¥–ª—è –≤–∏–¥–µ–æ
        self.setAcceptDrops(True)
        
        self.setup_ui()
        self.connect_signals()
        self._setup_shortcuts()
        self._create_menu()

    def _create_menu(self):
        """–°–æ–∑–¥–∞—Ç—å –º–µ–Ω—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è."""
        menubar = self.menuBar()
        
        # File menu
        file_menu = menubar.addMenu("File")
        
        new_action = file_menu.addAction("New Project")
        new_action.setShortcut("Ctrl+N")
        new_action.triggered.connect(self._on_new_project)
        
        open_action = file_menu.addAction("Open Project")
        open_action.setShortcut("Ctrl+O")
        open_action.triggered.connect(self._on_open_project)
        
        save_action = file_menu.addAction("Save Project")
        save_action.setShortcut("Ctrl+S")
        save_action.triggered.connect(self._on_save_project)
        
        save_as_action = file_menu.addAction("Save Project As...")
        save_as_action.setShortcut("Ctrl+Shift+S")
        save_as_action.triggered.connect(self._on_save_project_as)
        
        file_menu.addSeparator()
        
        # Recent projects
        self.recent_menu = file_menu.addMenu("Recent Projects")
        self._update_recent_menu()
        
        file_menu.addSeparator()
        
        exit_action = file_menu.addAction("Exit")
        exit_action.triggered.connect(self.close)
        
        # Help menu
        help_menu = menubar.addMenu("Help")
        about_action = help_menu.addAction("About")
        about_action.triggered.connect(self._on_about)

    def setup_ui(self):
        """–°–æ–∑–¥–∞—Ç—å UI."""
        central = QWidget()
        self.setCentralWidget(central)
        
        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(5)
        
        # ===== –í–ï–†–•–ù–Ø–Ø –ß–ê–°–¢–¨ (–≤–∏–¥–µ–æ + —Å–ø–∏—Å–æ–∫ —Å–ø—Ä–∞–≤–∞) =====
        top_layout = QHBoxLayout()
        
        # –í–∏–¥–µ–æ (70%)
        video_layout = QVBoxLayout()
        
        # –í–∏–¥–µ–æ –≤–∏–¥–∂–µ—Ç
        self.video_label = QLabel()
        self.video_label.setMinimumSize(800, 450)
        self.video_label.setStyleSheet("background-color: black; border: 1px solid grey;")
        video_layout.addWidget(self.video_label)
        
        # –ö–æ–Ω—Ç—Ä–æ–ª—ã –≤–∏–¥–µ–æ
        controls_layout = QHBoxLayout()
        
        self.play_btn = QPushButton("‚ñ∂ Play")
        self.play_btn.setMaximumWidth(80)
        self.play_btn.setToolTip("Play/Pause video (Space)")
        self.play_btn.clicked.connect(self._on_play_pause_clicked)
        controls_layout.addWidget(self.play_btn)
        
        # –ü–æ–ª–∑—É–Ω–æ–∫ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        self.progress_slider = QSlider(Qt.Orientation.Horizontal)
        self.progress_slider.setToolTip("Seek to frame")
        self.progress_slider.sliderMoved.connect(self._on_progress_slider_moved)
        controls_layout.addWidget(self.progress_slider)
        
        # –í—Ä–µ–º—è
        self.time_label = QLabel("00:00 / 00:00")
        self.time_label.setMaximumWidth(100)
        self.time_label.setToolTip("Current time / Total duration")
        controls_layout.addWidget(self.time_label)
        
        # –°–∫–æ—Ä–æ—Å—Ç—å (–≤—Å–µ–≥–¥–∞ 1x)
        speed_label = QLabel("1.0x")
        speed_label.setMaximumWidth(40)
        controls_layout.addWidget(speed_label)
        
        # –û—Ç–∫—Ä—ã—Ç—å –≤–∏–¥–µ–æ
        open_btn = QPushButton("üìÅ Open")
        open_btn.setMaximumWidth(70)
        open_btn.setToolTip("Open video file (Ctrl+O)")
        open_btn.clicked.connect(self._on_open_video)
        controls_layout.addWidget(open_btn)
        
        video_layout.addLayout(controls_layout)
        top_layout.addLayout(video_layout, 7)
        
        # –°–ø–∏—Å–æ–∫ –æ—Ç—Ä–µ–∑–∫–æ–≤ (30%)
        list_layout = QVBoxLayout()
        list_layout.addWidget(QLabel("Segments:"))
        
        self.markers_list = QListWidget()
        self.markers_list.itemDoubleClicked.connect(self._on_marker_double_clicked)
        list_layout.addWidget(self.markers_list)
        
        # –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–ø–∏—Å–∫–æ–º
        marker_btn_layout = QHBoxLayout()
        
        delete_btn = QPushButton("üóëÔ∏è Delete")
        delete_btn.clicked.connect(self._on_delete_marker)
        marker_btn_layout.addWidget(delete_btn)
        
        clear_btn = QPushButton("üóëÔ∏è Clear All")
        clear_btn.clicked.connect(self._on_clear_markers)
        marker_btn_layout.addWidget(clear_btn)
        
        list_layout.addLayout(marker_btn_layout)
        
        top_layout.addLayout(list_layout, 3)
        
        main_layout.addLayout(top_layout)
        
        # ===== –¢–ê–ô–ú–õ–ê–ô–ù =====
        main_layout.addWidget(QLabel("Timeline:"))
        
        # 1. –ü–µ—Ä–µ–¥–∞–µ–º –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä –°–†–ê–ó–£ –≤ —Å–∫–æ–±–∫–∞—Ö
        self.timeline_widget = TimelineWidget(self.controller)
        
        # 2. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –≥–ª–∞–≤–Ω–æ–µ –æ–∫–Ω–æ (–¥–ª—è –¥–≤–æ–π–Ω–æ–≥–æ –∫–ª–∏–∫–∞)
        # –í –Ω–æ–≤–æ–º –∫–æ–¥–µ –º—ã –æ–±—Ä–∞—â–∞–µ–º—Å—è –∫ scene –≤–Ω—É—Ç—Ä–∏ –≤–∏–¥–∂–µ—Ç–∞
        self.timeline_widget.scene.main_window = self
        
        # 3. –î–æ–±–∞–≤–ª—è–µ–º –≤–∏–¥–∂–µ—Ç –Ω–∞ —Ñ–æ—Ä–º—É
        main_layout.addWidget(self.timeline_widget)
        
        # ===== –ö–ù–û–ü–ö–ò –°–û–ë–´–¢–ò–ô (–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ) –ò –ù–ê–°–¢–†–û–ô–ö–ò =====
        event_layout = QHBoxLayout()

        # –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏—Ö –∫–Ω–æ–ø–æ–∫ —Å–æ–±—ã—Ç–∏–π
        self.event_buttons_layout = QHBoxLayout()
        event_layout.addLayout(self.event_buttons_layout)

        # –û–±–Ω–æ–≤–∏—Ç—å –∫–Ω–æ–ø–∫–∏ –∏–∑ event_manager
        self._update_event_buttons()

        event_layout.addStretch()
        
        # –ö–Ω–æ–ø–∫–∏ undo/redo
        undo_btn = QPushButton("‚Ü∂ Undo")
        undo_btn.setMaximumWidth(80)
        undo_btn.setToolTip("Undo last operation (Ctrl+Z)")
        undo_btn.clicked.connect(self._on_undo_clicked)
        event_layout.addWidget(undo_btn)
        
        redo_btn = QPushButton("‚Ü∑ Redo")
        redo_btn.setMaximumWidth(80)
        redo_btn.setToolTip("Redo last operation (Ctrl+Shift+Z)")
        redo_btn.clicked.connect(self._on_redo_clicked)
        event_layout.addWidget(redo_btn)
        
        # –ö–Ω–æ–ø–∫–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞
        preview_btn = QPushButton("üëÅÔ∏è Preview")
        preview_btn.setToolTip("Preview and filter segments")
        preview_btn.clicked.connect(self._on_preview_clicked)
        event_layout.addWidget(preview_btn)
        
        # –ö–Ω–æ–ø–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫
        settings_btn = QPushButton("‚öôÔ∏è Settings")
        settings_btn.setToolTip("Open settings dialog (Ctrl+,)")
        settings_btn.clicked.connect(self._on_settings_clicked)
        event_layout.addWidget(settings_btn)
        
        # –ö–Ω–æ–ø–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞
        export_btn = QPushButton("üíæ Export")
        export_btn.setToolTip("Export segments to video (Ctrl+E)")
        export_btn.clicked.connect(self._on_export_clicked)
        event_layout.addWidget(export_btn)
        
        event_layout.addStretch()
        
        # –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å-–±–∞—Ä
        self.status_label = QLabel("Ready")
        self.status_label.setStyleSheet("color: #ffcc00;")
        self.status_label.setMinimumWidth(400)
        event_layout.addWidget(self.status_label)
        
        main_layout.addLayout(event_layout)
        
        central.setLayout(main_layout)
        
        # –ü–æ–¥–∫–ª—é—á–∏—Ç—å —Å–∏–≥–Ω–∞–ª frame_ready –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤–∏–¥–µ–æ
        self.controller.frame_ready.connect(self._on_frame_ready)

    def _create_event_button(self, text: str, color: str) -> QPushButton:
        """–°–æ–∑–¥–∞—Ç—å –∫–Ω–æ–ø–∫—É —Å–æ–±—ã—Ç–∏—è."""
        btn = QPushButton(text)
        btn.setMinimumSize(120, 90)
        btn.setFont(QFont("Arial", 14, QFont.Weight.Bold))
        btn.setStyleSheet(f"""
            QPushButton {{
                background-color: {color};
                color: white;
                border: 2px solid {color};
                border-radius: 5px;
            }}
            QPushButton:hover {{
                background-color: {self._lighten_color(color)};
            }}
            QPushButton:pressed {{
                border: 3px solid yellow;
                background-color: {self._lighten_color(color)};
            }}
        """)
        return btn

    def _lighten_color(self, color_hex: str) -> str:
        """–°–≤–µ—Ç–ª–∞—è –≤–µ—Ä—Å–∏—è —Ü–≤–µ—Ç–∞ –¥–ª—è hover."""
        # –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
        return color_hex.replace("00", "33").replace("8b", "bb")

    def connect_signals(self):
        """–ü–æ–¥–∫–ª—é—á–∏—Ç—å —Å–∏–≥–Ω–∞–ª—ã –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞."""
        self.controller.playback_time_changed.connect(self._on_playback_time_changed)
        self.controller.markers_changed.connect(self._on_markers_changed)
        self.controller.recording_status_changed.connect(self._on_recording_status_changed)
        self.controller.timeline_update.connect(self._on_timeline_update)
        self.controller.frame_ready.connect(self._on_frame_ready)

        # –ü–æ–¥–∫–ª—é—á–∏—Ç—å —Å–∏–≥–Ω–∞–ª –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ–±—ã—Ç–∏–π
        self.event_manager.events_changed.connect(self._on_events_changed)
        self.event_manager.events_changed.connect(self._on_events_changed_timeline)

        # –ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        self.autosave_manager.start()

    def _on_play_pause_clicked(self):
        """–ö–Ω–æ–ø–∫–∞ Play/Pause - –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ."""
        self.controller.toggle_play_pause()
        self._update_play_btn_text()

    def _update_play_btn_text(self):
        """–û–±–Ω–æ–≤–∏—Ç—å —Ç–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏ Play/Pause."""
        if self.controller.playing:
            self.play_btn.setText("‚è∏ Pause")
        else:
            self.play_btn.setText("‚ñ∂ Play")

    def _on_progress_slider_moved(self):
        """–î–≤–∏–∂–µ–Ω–∏–µ –ø–æ–ª–∑—É–Ω–∫–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞."""
        frame_idx = self.progress_slider.value()
        self.controller.seek_frame(frame_idx)

    def _on_open_video(self):
        """–û—Ç–∫—Ä—ã—Ç—å –≤–∏–¥–µ–æ."""
        path, _ = QFileDialog.getOpenFileName(
            self, "Open Video", "", "Videos (*.mp4 *.avi *.mov *.mkv);;All (*.*)"
        )
        if path:
            if self.controller.load_video(path):
                self.status_label.setText(f"‚úì Loaded: {path.split('/')[-1]}")
                self._update_play_btn_text()
                self.progress_slider.setMaximum(self.controller.get_total_frames())
            else:
                QMessageBox.critical(self, "Error", "Failed to load video")

    def _on_event_btn_clicked(self, event_name: str):
        """–ù–∞–∂–∞—Ç–∏–µ –∫–Ω–æ–ø–∫–∏ —Å–æ–±—ã—Ç–∏—è."""
        self.controller.on_hotkey_pressed(event_name.upper())  # –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä –æ–∂–∏–¥–∞–µ—Ç key (—Å—Ç—Ä–æ–∫–∞)

    def _on_undo_clicked(self):
        """–û—Ç–º–µ–Ω–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é."""
        self.controller.undo()
        self._on_markers_changed()
    
    def _on_redo_clicked(self):
        """–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é."""
        self.controller.redo()
        self._on_markers_changed()

    def _on_preview_clicked(self):
        """–û—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –æ—Ç—Ä–µ–∑–∫–æ–≤."""
        if not self.controller.markers:
            QMessageBox.warning(self, "Warning", "No segments to preview")
            return
        
        from .preview_window import PreviewWindow
        self.preview_window = PreviewWindow(self.controller, self)
        self.preview_window.show()

    def _on_settings_clicked(self):
        """–û—Ç–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏."""
        dialog = SettingsDialog(self.controller, self)
        if dialog.exec():
            # –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å –≥–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏, –µ—Å–ª–∏ –æ–Ω–∏ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å
            self._rebind_hotkeys()

    def _on_export_clicked(self):
        """–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤–∏–¥–µ–æ."""
        if not self.controller.markers:
            QMessageBox.warning(self, "Warning", "No segments to export")
            return
        
        from .export_dialog import ExportDialog
        dialog = ExportDialog(self.controller, self)
        dialog.exec()

    def _on_marker_double_clicked(self, item: QListWidgetItem):
        """–î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –Ω–∞ –æ—Ç—Ä–µ–∑–æ–∫ = —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ."""
        idx = self.markers_list.row(item)
        dialog = SegmentEditorDialog(self.controller, idx, self)
        dialog.exec()

    def _on_delete_marker(self):
        """–£–¥–∞–ª–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π –æ—Ç—Ä–µ–∑–æ–∫."""
        current_idx = self.markers_list.currentRow()
        if current_idx >= 0:
            self.controller.delete_marker(current_idx)

    def _on_clear_markers(self):
        """–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –æ—Ç—Ä–µ–∑–∫–∏."""
        reply = QMessageBox.question(self, "Confirm", "Delete all segments?")
        if reply == QMessageBox.StandardButton.Yes:
            self.controller.clear_markers()

    def _on_playback_time_changed(self, frame_idx: int):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è."""
        fps = self.controller.get_fps()
        total_frames = self.controller.get_total_frames()
        
        self.progress_slider.blockSignals(True)
        self.progress_slider.setValue(frame_idx)
        self.progress_slider.blockSignals(False)
        
        # –û–±–Ω–æ–≤–∏—Ç—å –≤—Ä–µ–º—è
        if fps > 0:
            current_sec = frame_idx / fps
            total_sec = total_frames / fps
            self.time_label.setText(self._format_time(current_sec, total_sec))
        
        # –û–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å-–±–∞—Ä
        self._update_status_bar()

    def _on_markers_changed(self):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –æ—Ç—Ä–µ–∑–∫–æ–≤."""
        self.markers_list.clear()
        fps = self.controller.get_fps()

        for idx, marker in enumerate(self.controller.markers):
            start_time = self._format_time_single(marker.start_frame / fps if fps > 0 else 0)
            end_time = self._format_time_single(marker.end_frame / fps if fps > 0 else 0)
            text = f"{idx+1}. {marker.event_name} ({start_time}‚Äì{end_time})"
            self.markers_list.addItem(text)
        
        # –û–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å-–±–∞—Ä
        self._update_status_bar()

    def _on_recording_status_changed(self, event_type: str, status: str):
        """–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–ø–∏—Å–∏."""
        if status == "Recording":
            self.status_label.setText(f"üî¥ Recording: {event_type}")
            self.status_label.setStyleSheet("color: #ff0000;")
        elif status == "Complete":
            self.status_label.setText(f"‚úì Complete: {event_type}")
            self.status_label.setStyleSheet("color: #00ff00;")
        elif status == "Fixed":
            self.status_label.setText(f"‚úì Fixed: {event_type}")
            self.status_label.setStyleSheet("color: #00ff00;")
        elif status == "Cancelled":
            self.status_label.setText("‚èπÔ∏è Cancelled")
            self.status_label.setStyleSheet("color: #ffcc00;")
        else:
            self.status_label.setText("Ready")
            self.status_label.setStyleSheet("color: #ffcc00;")

    def _on_timeline_update(self):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–∞–π–º–ª–∞–π–Ω–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ñ—Ä–µ–π–º–∞."""
        if hasattr(self.timeline_widget, 'scene_obj'):
            current_frame = self.controller.get_current_frame_idx()
            self.timeline_widget.scene_obj.update_playhead(current_frame)

    # –ò–°–ü–†–ê–í–õ–ï–ù–û: —É–¥–∞–ª–µ–Ω –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ—Ç–æ–¥ _setup_shortcuts —Å EventType

    def _on_events_changed(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ–±—ã—Ç–∏–π - –æ–±–Ω–æ–≤–∏—Ç—å –∫–Ω–æ–ø–∫–∏ –∏ shortcuts."""
        self._update_event_buttons()
        self._setup_event_shortcuts()

    def _on_events_changed_timeline(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ–±—ã—Ç–∏–π –¥–ª—è —Ç–∞–π–º–ª–∞–π–Ω–∞."""
        if hasattr(self.timeline_widget, 'scene_obj'):
            self.timeline_widget.scene_obj.update_scene()

    def _update_event_buttons(self):
        """–û–±–Ω–æ–≤–∏—Ç—å –∫–Ω–æ–ø–∫–∏ —Å–æ–±—ã—Ç–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ CustomEventManager."""
        # –û—á–∏—Å—Ç–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∫–Ω–æ–ø–∫–∏
        for i in reversed(range(self.event_buttons_layout.count())):
            widget = self.event_buttons_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)

        # –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–æ–±—ã—Ç–∏—è
        events = self.event_manager.get_all_events()
        for event in events:
            text = f"{event.shortcut.upper()}\n{event.name}"
            btn = self._create_event_button(text, event.color)
            btn.clicked.connect(lambda checked, e=event.name: self._on_event_btn_clicked(e))
            btn.setToolTip(f"Add {event.name} event ({event.shortcut.upper()})")
            self.event_buttons_layout.addWidget(btn)

    def _setup_shortcuts(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≥–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏ —á–µ—Ä–µ–∑ ShortcutManager."""
        # –û—á–∏—Å—Ç–∏—Ç—å —Å—Ç–∞—Ä—ã–µ shortcuts –¥–ª—è —Å–æ–±—ã—Ç–∏–π (–µ—Å–ª–∏ –µ—Å—Ç—å)
        for event in self.event_manager.get_all_events():
            self.shortcut_manager.unregister_shortcut(event.name.upper())

        # –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å shortcuts –¥–ª—è –≤—Å–µ—Ö —Å–æ–±—ã—Ç–∏–π
        self._setup_event_shortcuts()

        # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å shortcuts –¥–ª—è –æ—Å–Ω–æ–≤–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
        self.shortcut_manager.register_shortcut('PLAY_PAUSE', 'Space', self._on_play_pause_clicked)
        self.shortcut_manager.register_shortcut('OPEN_VIDEO', 'Ctrl+O', self._on_open_video)
        self.shortcut_manager.register_shortcut('CANCEL', 'Escape', self._on_cancel_recording)
        self.shortcut_manager.register_shortcut('SETTINGS', 'Ctrl+Comma', self._on_settings_clicked)
        self.shortcut_manager.register_shortcut('EXPORT', 'Ctrl+E', self._on_export_clicked)
        self.shortcut_manager.register_shortcut('UNDO', 'Ctrl+Z', self._on_undo_clicked)
        self.shortcut_manager.register_shortcut('REDO', 'Ctrl+Shift+Z', self._on_redo_clicked)

    def _setup_event_shortcuts(self):
        """–°–æ–∑–¥–∞—ë—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –≥–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏ –¥–ª—è –≤—Å–µ—Ö —Å–æ–±—ã—Ç–∏–π (A, D, S –∏ –∫–∞—Å—Ç–æ–º–Ω—ã–µ)."""
        if hasattr(self, '_event_shortcuts'):
            for s in self._event_shortcuts:
                s.activated.disconnect()
                s.setParent(None)
            self._event_shortcuts.clear()
        else:
            self._event_shortcuts = []

        for event in self.event_manager.get_all_events():
            if not event.shortcut:
                continue

            shortcut = QShortcut(QKeySequence(event.shortcut.upper()), self)
            # –ü–†–ê–í–ò–õ–¨–ù–´–ô –≤—ã–∑–æ–≤ ‚Äî –ø–µ—Ä–µ–¥–∞—ë–º —Ç–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫—É —Å –∫–ª–∞–≤–∏—à–µ–π
            shortcut.activated.connect(
                lambda checked=False, key=event.shortcut.upper(): self.controller.on_hotkey_pressed(key)
            )
            self._event_shortcuts.append(shortcut)

    def _rebind_hotkeys(self):
        """–ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å –≥–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏ –ø–æ—Å–ª–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö."""
        # –ü–µ—Ä–µ—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ shortcuts
        self._setup_shortcuts()

    def _on_cancel_recording(self):
        """–û—Ç–º–µ–Ω–∞ –∑–∞–ø–∏—Å–∏ (Escape)."""
        self.controller.cancel_recording()
        self._update_play_btn_text()

    def _on_selection_changed(self) -> None:
        """Handle event selection change."""
        selected = self.event_list.selectedItems()
        has_selection = len(selected) > 0
        
        self.edit_btn.setEnabled(has_selection)
        
        # Can only delete non-default events
        if has_selection:
            event_name = selected[0].data(Qt.UserRole) 
            event = self.manager.get_event(event_name)
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ None
            if event is None:
                self.delete_btn.setEnabled(False)
                return
            
            is_default = event.name in {e.name for e in self.manager.DEFAULT_EVENTS}
            self.delete_btn.setEnabled(has_selection and not is_default)
        else:
            self.delete_btn.setEnabled(False)

    def _update_video_frame(self):
        """–û–±–Ω–æ–≤–∏—Ç—å –≤–∏–¥–µ–æ –∫–∞–¥—Ä –Ω–∞ —ç–∫—Ä–∞–Ω–µ (—á–µ—Ä–µ–∑ —Å–∏–≥–Ω–∞–ª frame_ready)."""
        pass  # –í–∏–¥–µ–æ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ frame_ready —Å–∏–≥–Ω–∞–ª

    def _on_frame_ready(self, frame):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ—Ç–æ–≤–æ–≥–æ –∫–∞–¥—Ä–∞ –∏–∑ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞."""
        if frame is None:
            return
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å BGR –≤ RGB
        import cv2
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        h, w, ch = frame_rgb.shape
        bytes_per_line = ch * w
        qt_image = QImage(frame_rgb.data, w, h, bytes_per_line, QImage.Format.Format_RGB888)
        
        # –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞—Ç—å –ø–æ–¥ —Ä–∞–∑–º–µ—Ä label
        pixmap = QPixmap.fromImage(qt_image)
        pixmap = pixmap.scaledToWidth(800, Qt.TransformationMode.SmoothTransformation)
        self.video_label.setPixmap(pixmap)

    def _format_time(self, current_sec: float, total_sec: float) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Ä–µ–º—è MM:SS / MM:SS."""
        def fmt(s):
            m = int(s) // 60
            s = int(s) % 60
            return f"{m:02d}:{s:02d}"
        return f"{fmt(current_sec)} / {fmt(total_sec)}"

    def _format_time_single(self, seconds: float) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Ä–µ–º—è MM:SS."""
        minutes = int(seconds) // 60
        secs = int(seconds) % 60
        return f"{minutes:02d}:{secs:02d}"

    def _get_dark_stylesheet(self) -> str:
        """–¢—ë–º–Ω—ã–π —Å—Ç–∏–ª—å."""
        return """
        QMainWindow, QWidget {
            background-color: #1a1a1a;
            color: #ffffff;
        }
        QPushButton {
            background-color: #333333;
            color: white;
            border: 1px solid #555555;
            padding: 5px;
            border-radius: 3px;
        }
        QPushButton:hover {
            background-color: #444444;
        }
        QSlider::groove:horizontal {
            background: #333333;
            height: 6px;
            border-radius: 3px;
        }
        QSlider::handle:horizontal {
            background: #ffcc00;
            width: 14px;
            margin: -4px 0;
            border-radius: 7px;
        }
        QListWidget {
            background-color: #2a2a2a;
            color: #ffffff;
            border: 1px solid #555555;
        }
        QLabel {
            color: #ffffff;
        }
        QComboBox {
            background-color: #333333;
            color: #ffffff;
            border: 1px solid #555555;
        }
        """

    # ===== MENU HANDLERS =====
    
    def _on_new_project(self):
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç."""
        self.controller.markers.clear()
        self.controller.markers_changed.emit()
        QMessageBox.information(self, "New Project", "Project cleared")
    
    def _on_open_project(self):
        """–û—Ç–∫—Ä—ã—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –ø—Ä–æ–µ–∫—Ç."""
        path, _ = QFileDialog.getOpenFileName(
            self, "Open Project", "", "Hockey Editor Projects (*.hep);;All Files (*)"
        )
        
        if path:
            if self.controller.load_project(path):
                QMessageBox.information(self, "Success", f"Project loaded: {path}")
            else:
                QMessageBox.critical(self, "Error", f"Failed to load project: {path}")
    
    def _on_save_project(self):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–µ–∫—Ç."""
        if not hasattr(self, 'current_project_path') or not self.current_project_path:
            self._on_save_project_as()
        else:
            if self.controller.save_project(self.current_project_path):
                QMessageBox.information(self, "Success", "Project saved")
            else:
                QMessageBox.critical(self, "Error", "Failed to save project")
    
    def _on_save_project_as(self):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–µ–∫—Ç –∫–∞–∫ –Ω–æ–≤—ã–π —Ñ–∞–π–ª."""
        path, _ = QFileDialog.getSaveFileName(
            self, "Save Project As", "", "Hockey Editor Projects (*.hep);;All Files (*)"
        )
        
        if path:
            if self.controller.save_project(path):
                self.current_project_path = path
                self.setWindowTitle(f"Hockey Editor Pro - {Path(path).name}")
                QMessageBox.information(self, "Success", "Project saved")
            else:
                QMessageBox.critical(self, "Error", "Failed to save project")
    
    def _update_recent_menu(self):
        """–û–±–Ω–æ–≤–∏—Ç—å –º–µ–Ω—é –Ω–µ–¥–∞–≤–Ω–∏—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤."""
        self.recent_menu.clear()
        
        recent_projects = self.controller.get_recent_projects()
        if not recent_projects:
            self.recent_menu.addAction("(No recent projects)")
            return
        
        for path in recent_projects:
            action = self.recent_menu.addAction(Path(path).name)
            action.triggered.connect(lambda checked, p=path: self._on_recent_project(p))
    
    def _on_recent_project(self, path: str):
        """–û—Ç–∫—Ä—ã—Ç—å –Ω–µ–¥–∞–≤–Ω–∏–π –ø—Ä–æ–µ–∫—Ç."""
        if self.controller.load_project(path):
            QMessageBox.information(self, "Success", f"Project loaded: {path}")
            self._update_recent_menu()
        else:
            QMessageBox.critical(self, "Error", f"Failed to load project: {path}")
    
    def _on_about(self):
        """–û –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏."""
        QMessageBox.information(
            self, "About Hockey Editor Pro",
            "Hockey Editor Pro v1.0\n"
            "Professional Video Analysis Tool\n\n"
            "Hotkeys:\n"
            "A - Attack\n"
            "D - Defense\n"
            "S - Shift\n"
            "Space - Play/Pause\n"
            "Ctrl+O - Open Video\n"
            "Ctrl+E - Export\n"
            "Ctrl+, - Settings"
        )

    def _on_autosave_completed(self, success: bool, message: str):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è."""
        if success:
            self.status_label.setText(f"‚úì {message}")
        else:
            print(f"Autosave error: {message}")

    def dragEnterEvent(self, event):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥–∞ drag-drop."""
        if event.mimeData().hasUrls():
            event.acceptProposedAction()

    def dropEvent(self, event):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ drop –≤–∏–¥–µ–æ—Ñ–∞–π–ª–∞."""
        for url in event.mimeData().urls():
            file_path = url.toLocalFile()
            if file_path.lower().endswith(('.mp4', '.avi', '.mov', '.mkv', '.flv', '.wmv')):
                self.controller.load_video(file_path)
                break

    def open_segment_editor(self, marker_idx: int):
        """–û—Ç–∫—Ä—ã—Ç—å —Ä–µ–¥–∞–∫—Ç–æ—Ä —Å–µ–≥–º–µ–Ω—Ç–∞ (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ timeline –ø—Ä–∏ double-click)."""
        if 0 <= marker_idx < len(self.controller.markers):
            dialog = SegmentEditorDialog(self.controller, marker_idx, self)
            dialog.exec()
    
    def _update_status_bar(self):
        """–û–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å-–±–∞—Ä —Å –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π."""
        fps = self.controller.get_fps()
        current_frame = self.controller.get_current_frame_idx()
        total_frames = self.controller.get_total_frames()
        
        if fps > 0 and total_frames > 0:
            current_time = self._format_time_single(current_frame / fps)
            total_time = self._format_time_single(total_frames / fps)
            segment_count = len(self.controller.markers)
            
            status = f"{current_time}/{total_time} | {segment_count} segments | FPS: {fps:.2f}"
            
            # –ï—Å–ª–∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ, –¥–æ–±–∞–≤–∏—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
            if self.controller.playing:
                status = "‚ñ∂ " + status
            
            self.status_label.setText(status)
        else:
            self.status_label.setText("Ready")

    def closeEvent(self, event):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –æ–∫–Ω–∞."""
        self.autosave_manager.stop()
        self.controller.cleanup()
        event.accept()


===== preview_window.py =====
"""
Preview Window - –ø—Ä–æ—Å–º–æ—Ç—Ä –∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –æ—Ç—Ä–µ–∑–∫–æ–≤ (PySide6).
–ù–µ–º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ —Å –≤–∏–¥–µ–æ–ø–ª–µ–µ—Ä–æ–º –∏ —Å–ø–∏—Å–∫–æ–º –æ—Ç—Ä–µ–∑–∫–æ–≤.
"""

from PySide6.QtCore import Qt, QTimer, Signal
from PySide6.QtGui import QPixmap, QImage, QFont, QColor
from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QSlider, QListWidget, QListWidgetItem, QCheckBox, QComboBox, QGroupBox
)
import cv2
import numpy as np
from typing import Optional
from ..models.marker import Marker, EventType


class PreviewWindow(QMainWindow):
    """
    –û–∫–Ω–æ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –æ—Ç—Ä–µ–∑–∫–æ–≤.
    –°–æ–¥–µ—Ä–∂–∏—Ç –≤–∏–¥–µ–æ–ø–ª–µ–µ—Ä –∏ —Å–ø–∏—Å–æ–∫ –æ—Ç—Ä–µ–∑–∫–æ–≤ —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π.
    """
    
    def __init__(self, controller, parent=None):
        super().__init__(parent)
        self.controller = controller
        self.setWindowTitle("Preview - Segments")
        self.setGeometry(100, 100, 1400, 800)
        self.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose)  # –ù–µ–º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ
        self.setStyleSheet(self._get_dark_stylesheet())
        
        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
        self.current_marker_idx = 0
        self.is_playing = False
        self.playback_timer = QTimer()
        self.playback_timer.timeout.connect(self._on_playback_tick)
        self.frame_time_ms = 33  # ~30 FPS
        
        self._create_filter_checkboxes()
        self._setup_ui()
        self._update_marker_list()

    def _create_filter_checkboxes(self):
        """–°–æ–∑–¥–∞—Ç—å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ checkbox –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —Å–æ–±—ã—Ç–∏–π."""
        # –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è –∏–∑ CustomEventManager
        from ..utils.custom_events import get_custom_event_manager
        event_manager = get_custom_event_manager()
        events = event_manager.get_all_events()

        # –û—á–∏—Å—Ç–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ checkbox
        self.filter_checkboxes = {}

        for event in events:
            checkbox = QCheckBox(f"{event.name} ({event.shortcut})")
            checkbox.setChecked(True)
            checkbox.setToolTip(f"Show/hide {event.name} events")
            checkbox.stateChanged.connect(self._update_marker_list)

            # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –∫–∞–∫ —Ü–≤–µ—Ç —Å–æ–±—ã—Ç–∏—è
            checkbox.setStyleSheet(f"""
                QCheckBox {{
                    color: {event.color};
                }}
            """)

            self.filter_checkboxes[event.name] = checkbox

    def _setup_ui(self):
        """–°–æ–∑–¥–∞—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å."""
        central = QWidget()
        self.setCentralWidget(central)
        
        main_layout = QHBoxLayout()
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)
        
        # ===== –õ–ï–í–ê–Ø –ß–ê–°–¢–¨: –í–ò–î–ï–û–ü–õ–ï–ï–† (70%) =====
        video_layout = QVBoxLayout()
        
        # –í–∏–¥–µ–æ
        self.video_label = QLabel()
        self.video_label.setMinimumSize(800, 450)
        self.video_label.setStyleSheet("background-color: black; border: 1px solid #555555;")
        self.video_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.video_label.setToolTip("Preview video player")
        video_layout.addWidget(self.video_label)
        
        # –ö–æ–Ω—Ç—Ä–æ–ª—ã –≤–∏–¥–µ–æ
        controls_layout = QHBoxLayout()
        
        self.play_btn = QPushButton("‚ñ∂ Play")
        self.play_btn.setMaximumWidth(80)
        self.play_btn.setToolTip("Play/Pause preview (Space)")
        self.play_btn.clicked.connect(self._on_play_pause_clicked)
        controls_layout.addWidget(self.play_btn)
        
        # –ü–æ–ª–∑—É–Ω–æ–∫
        self.progress_slider = QSlider(Qt.Orientation.Horizontal)
        self.progress_slider.setToolTip("Seek within current segment")
        self.progress_slider.sliderMoved.connect(self._on_slider_moved)
        controls_layout.addWidget(self.progress_slider)
        
        # –í—Ä–µ–º—è
        self.time_label = QLabel("00:00 / 00:00")
        self.time_label.setMaximumWidth(120)
        self.time_label.setToolTip("Current time / Segment duration")
        controls_layout.addWidget(self.time_label)
        
        # –°–∫–æ—Ä–æ—Å—Ç—å
        speed_label = QLabel("Speed:")
        controls_layout.addWidget(speed_label)
        self.speed_combo = QComboBox()
        self.speed_combo.addItems(["0.5x", "1.0x", "2.0x"])
        self.speed_combo.setCurrentIndex(1)
        self.speed_combo.setMaximumWidth(80)
        self.speed_combo.setToolTip("Playback speed")
        self.speed_combo.currentIndexChanged.connect(self._update_frame_time)
        controls_layout.addWidget(self.speed_combo)
        
        controls_layout.addStretch()
        video_layout.addLayout(controls_layout)
        
        main_layout.addLayout(video_layout, 7)
        
        # ===== –ü–†–ê–í–ê–Ø –ß–ê–°–¢–¨: –°–ü–ò–°–û–ö –û–¢–†–ï–ó–ö–û–í (30%) =====
        list_layout = QVBoxLayout()
        
        # –§–∏–ª—å—Ç—Ä—ã (–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∏–∑ CustomEventManager)
        filter_group = QGroupBox("Filter Events")
        self.filter_layout = QVBoxLayout()
        
        # –î–æ–±–∞–≤–∏—Ç—å —á–µ–∫–±–æ–∫—Å—ã –≤ layout
        for event_name, checkbox in self.filter_checkboxes.items():
            self.filter_layout.addWidget(checkbox)
        
        filter_group.setLayout(self.filter_layout)
        list_layout.addWidget(filter_group)
        
        # –°–ø–∏—Å–æ–∫ –æ—Ç—Ä–µ–∑–∫–æ–≤
        self.markers_list = QListWidget()
        self.markers_list.setToolTip("Click to preview segment")
        self.markers_list.itemClicked.connect(self._on_marker_selected)
        list_layout.addWidget(self.markers_list)
        
        # –ö–Ω–æ–ø–∫–∏
        btn_layout = QHBoxLayout()
        
        edit_btn = QPushButton("‚úé Edit")
        edit_btn.setToolTip("Edit selected segment")
        edit_btn.clicked.connect(self._on_edit_marker)
        btn_layout.addWidget(edit_btn)
        
        delete_btn = QPushButton("üóëÔ∏è Delete")
        delete_btn.setToolTip("Delete selected segment")
        delete_btn.clicked.connect(self._on_delete_marker)
        btn_layout.addWidget(delete_btn)
        
        list_layout.addLayout(btn_layout)
        
        main_layout.addLayout(list_layout, 3)
        
        central.setLayout(main_layout)

    def _update_marker_list(self):
        """–û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –æ—Ç—Ä–µ–∑–∫–æ–≤ —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π."""
        self.markers_list.clear()

        fps = self.controller.get_fps()

        # –ü–æ–ª—É—á–∏—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
        active_filters = {}
        for event_name, checkbox in self.filter_checkboxes.items():
            active_filters[event_name] = checkbox.isChecked()

        for idx, marker in enumerate(self.controller.markers):
            # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Å–æ–±—ã—Ç–∏—è–º
            if not active_filters.get(marker.event_name, True):
                continue

            start_time = self._format_time(marker.start_frame / fps if fps > 0 else 0)
            end_time = self._format_time(marker.end_frame / fps if fps > 0 else 0)
            duration_frames = marker.end_frame - marker.start_frame
            duration_sec = duration_frames / fps if fps > 0 else 0

            text = f"{idx+1}. {marker.event_name} ({start_time}‚Äì{end_time}) [{duration_sec:.1f}s]"

            item = QListWidgetItem(text)
            item.setData(Qt.ItemDataRole.UserRole, idx)  # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å

            # –ü–æ–ª—É—á–∏—Ç—å —Ü–≤–µ—Ç —Å–æ–±—ã—Ç–∏—è –∏–∑ CustomEventManager
            from ..utils.custom_events import get_custom_event_manager
            event_manager = get_custom_event_manager()
            event = event_manager.get_event(marker.event_name)
            if event:
                item.setForeground(event.get_qcolor())
            else:
                item.setForeground(QColor(150, 150, 150))  # –°–µ—Ä—ã–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

            self.markers_list.addItem(item)

    def _on_marker_selected(self, item: QListWidgetItem):
        """–ö–ª–∏–∫ –Ω–∞ –æ—Ç—Ä–µ–∑–æ–∫ = –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Å –Ω–∞—á–∞–ª–∞."""
        marker_idx = item.data(Qt.ItemDataRole.UserRole)
        self.current_marker_idx = marker_idx
        
        marker = self.controller.markers[marker_idx]
        self.controller.seek_frame(marker.start_frame)
        self._display_current_frame()
        self._update_slider()
        
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞—á–∞—Ç—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ
        if not self.is_playing:
            self._on_play_pause_clicked()

    def _on_play_pause_clicked(self):
        """–ö–Ω–æ–ø–∫–∞ Play/Pause."""
        if not self.controller.markers:
            return
        
        if self.is_playing:
            self.playback_timer.stop()
            self.is_playing = False
            self.play_btn.setText("‚ñ∂ Play")
        else:
            self.is_playing = True
            self.play_btn.setText("‚è∏ Pause")
            self.playback_timer.start(self.frame_time_ms)

    def _on_playback_tick(self):
        """–¢–∞–π–º–µ—Ä –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è."""
        if not self.controller.markers or self.current_marker_idx >= len(self.controller.markers):
            self.is_playing = False
            self.play_btn.setText("‚ñ∂ Play")
            self.playback_timer.stop()
            return
        
        marker = self.controller.markers[self.current_marker_idx]
        current_frame = self.controller.processor.get_current_frame_idx()
        
        # –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–ª–∏ –∫–æ–Ω—Ü–∞ –æ—Ç—Ä–µ–∑–∫–∞
        if current_frame >= marker.end_frame:
            # –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å—Å—è –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –æ—Ç—Ä–µ–∑–æ–∫ (—Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π)
            self._go_to_next_marker()
            return
        
        # –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ —Å–ª–µ–¥—É—é—â–∏–π –∫–∞–¥—Ä
        self.controller.processor.advance_frame()
        self._display_current_frame()
        self._update_slider()

    def _go_to_next_marker(self):
        """–ü–µ—Ä–µ–π—Ç–∏ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –æ—Ç—Ä–µ–∑–æ–∫ (—Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π)."""
        # –ù–∞–π—Ç–∏ —Å–ª–µ–¥—É—é—â–∏–π –æ—Ç—Ä–µ–∑–æ–∫, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Ñ–∏–ª—å—Ç—Ä—É
        for idx in range(self.current_marker_idx + 1, len(self.controller.markers)):
            marker = self.controller.markers[idx]
            # –ü–æ–ª—É—á–∏—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
            active_filters = {}
            for event_name, checkbox in self.filter_checkboxes.items():
                active_filters[event_name] = checkbox.isChecked()
            
            if active_filters.get(marker.event_name, True):
                self.current_marker_idx = idx
                self.controller.seek_frame(marker.start_frame)
                self.markers_list.setCurrentRow(idx)
                self._display_current_frame()
                self._update_slider()
                return
        
        # –ö–æ–Ω–µ—Ü —Å–ø–∏—Å–∫–∞
        self.is_playing = False
        self.play_btn.setText("‚ñ∂ Play")
        self.playback_timer.stop()

    def _on_slider_moved(self):
        """–î–≤–∏–∂–µ–Ω–∏–µ –ø–æ–ª–∑—É–Ω–∫–∞."""
        frame_idx = self.progress_slider.value()
        self.controller.seek_frame(frame_idx)
        self._display_current_frame()
        self._update_slider()

    def _on_edit_marker(self):
        """–û—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π –æ—Ç—Ä–µ–∑–æ–∫."""
        current_idx = self.markers_list.currentRow()
        if current_idx < 0:
            return
        
        marker_idx = self.markers_list.item(current_idx).data(Qt.ItemDataRole.UserRole)
        from .edit_segment_dialog import EditSegmentDialog
        marker = self.controller.markers[marker_idx]
        dialog = EditSegmentDialog(marker, self.controller.get_fps(), self)
        if dialog.exec():
            self.controller.markers[marker_idx] = dialog.get_marker()
            self.controller.markers_changed.emit()
        self._update_marker_list()

    def _on_delete_marker(self):
        """–£–¥–∞–ª–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π –æ—Ç—Ä–µ–∑–æ–∫."""
        current_idx = self.markers_list.currentRow()
        if current_idx < 0:
            return
        
        marker_idx = self.markers_list.item(current_idx).data(Qt.ItemDataRole.UserRole)
        self.controller.delete_marker(marker_idx)
        self._update_marker_list()

    def _display_current_frame(self):
        """–û—Ç–æ–±—Ä–∞–∑–∏—Ç—å —Ç–µ–∫—É—â–∏–π –∫–∞–¥—Ä."""
        frame = self.controller.processor.get_current_frame()
        if frame is None:
            return
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å BGR –≤ RGB
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        h, w, ch = frame_rgb.shape
        bytes_per_line = ch * w
        qt_image = QImage(frame_rgb.data, w, h, bytes_per_line, QImage.Format.Format_RGB888)
        
        # –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞—Ç—å
        pixmap = QPixmap.fromImage(qt_image)
        pixmap = pixmap.scaledToWidth(800, Qt.TransformationMode.SmoothTransformation)
        self.video_label.setPixmap(pixmap)

    def _update_slider(self):
        """–û–±–Ω–æ–≤–∏—Ç—å –ø–æ–ª–∑—É–Ω–æ–∫ –∏ –≤—Ä–µ–º—è."""
        if not self.controller.markers or self.current_marker_idx >= len(self.controller.markers):
            return
        
        marker = self.controller.markers[self.current_marker_idx]
        current_frame = self.controller.processor.get_current_frame_idx()
        fps = self.controller.get_fps()
        
        # –ü–æ–ª–∑—É–Ω–æ–∫
        self.progress_slider.blockSignals(True)
        self.progress_slider.setMinimum(marker.start_frame)
        self.progress_slider.setMaximum(marker.end_frame)
        self.progress_slider.setValue(current_frame)
        self.progress_slider.blockSignals(False)
        
        # –í—Ä–µ–º—è
        if fps > 0:
            current_time = current_frame / fps
            end_time = marker.end_frame / fps
            self.time_label.setText(f"{self._format_time(current_time)} / {self._format_time(end_time)}")

    def _update_frame_time(self):
        """–û–±–Ω–æ–≤–∏—Ç—å frame_time_ms –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏."""
        speed_text = self.speed_combo.currentText()
        speed = float(speed_text.replace('x', '')) 
        fps = self.controller.get_fps()
        if fps > 0:
            self.frame_time_ms = int(1000 / (fps * speed))

    def _format_time(self, seconds: float) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Ä–µ–º—è MM:SS."""
        minutes = int(seconds) // 60
        secs = int(seconds) % 60
        return f"{minutes:02d}:{secs:02d}"

    def _get_dark_stylesheet(self) -> str:
        """–¢—ë–º–Ω—ã–π —Å—Ç–∏–ª—å."""
        return """
        QMainWindow, QWidget {
            background-color: #1a1a1a;
            color: #ffffff;
        }
        QPushButton {
            background-color: #333333;
            color: white;
            border: 1px solid #555555;
            padding: 5px;
            border-radius: 3px;
        }
        QPushButton:hover {
            background-color: #444444;
        }
        QSlider::groove:horizontal {
            background: #333333;
            height: 6px;
            border-radius: 3px;
        }
        QSlider::handle:horizontal {
            background: #ffcc00;
            width: 14px;
            margin: -4px 0;
            border-radius: 7px;
        }
        QListWidget {
            background-color: #2a2a2a;
            color: #ffffff;
            border: 1px solid #555555;
        }
        QLabel, QCheckBox {
            color: #ffffff;
        }
        QComboBox {
            background-color: #333333;
            color: #ffffff;
            border: 1px solid #555555;
        }
        QGroupBox {
            border: 1px solid #555555;
            border-radius: 4px;
            margin-top: 8px;
            padding-top: 8px;
        }
        """


===== segment_editor.py =====
# ui/segment_editor.py
# –ü–æ–ª–Ω–æ—Å—Ç—å—é –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è ‚Äî —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –Ω–æ–≤–æ–π –º–æ–¥–µ–ª—å—é Marker (event_name)

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QSpinBox, QPushButton, QComboBox, QDialogButtonBox
)
from PySide6.QtCore import Qt
from ..utils.custom_events import get_custom_event_manager


class SegmentEditorDialog(QDialog):
    """–î–∏–∞–ª–æ–≥ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç—Ä–µ–∑–∫–∞"""

    def __init__(self, controller, marker_idx, parent=None):
        super().__init__(parent)
        self.controller = controller
        self.marker_idx = marker_idx
        self.marker = controller.markers[marker_idx]
        self.event_manager = get_custom_event_manager()

        self.setWindowTitle(f"Edit Segment - {self.marker.event_name}")
        self.setModal(True)
        self.resize(400, 250)

        layout = QVBoxLayout(self)

        # === –ò–º—è —Å–æ–±—ã—Ç–∏—è ===
        event_layout = QHBoxLayout()
        event_layout.addWidget(QLabel("Event:"))
        self.event_combo = QComboBox()
        for event in self.event_manager.get_all_events():
            self.event_combo.addItem(event.name, event.name)
        self.event_combo.setCurrentText(self.marker.event_name)
        event_layout.addWidget(self.event_combo)
        layout.addLayout(event_layout)

        # === –ù–∞—á–∞–ª–æ ===
        start_layout = QHBoxLayout()
        start_layout.addWidget(QLabel("Start frame:"))
        self.start_spin = QSpinBox()
        self.start_spin.setRange(0, controller.get_total_frames() - 1)
        self.start_spin.setValue(self.marker.start_frame)
        start_layout.addWidget(self.start_spin)
        layout.addLayout(start_layout)

        # === –ö–æ–Ω–µ—Ü ===
        end_layout = QHBoxLayout()
        end_layout.addWidget(QLabel("End frame:"))
        self.end_spin = QSpinBox()
        self.end_spin.setRange(0, controller.get_total_frames() - 1)
        self.end_spin.setValue(self.marker.end_frame)
        self.end_spin.setMinimum(self.marker.start_frame + 1)
        end_layout.addWidget(self.end_spin)
        layout.addLayout(end_layout)

        # === –ó–∞–º–µ—Ç–∫–∞ ===
        note_layout = QHBoxLayout()
        note_layout.addWidget(QLabel("Note:"))
        self.note_edit = QLineEdit(self.marker.note)
        note_layout.addWidget(self.note_edit)
        layout.addLayout(note_layout)

        # === –ö–Ω–æ–ø–∫–∏ ===
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        # –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å–ø–∏–Ω–±–æ–∫—Å–æ–≤
        self.start_spin.valueChanged.connect(self._on_start_changed)
        self.end_spin.valueChanged.connect(self._on_end_changed)

    def _on_start_changed(self, value):
        if value >= self.marker.end_frame:
            self.end_spin.setValue(value + 1)
        self.end_spin.setMinimum(value + 1)

    def _on_end_changed(self, value):
        if value <= self.marker.start_frame:
            self.start_spin.setValue(value - 1)
        self.start_spin.setMaximum(value - 1)

    def accept(self):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è"""
        old_marker = self.marker

        new_marker = type(old_marker)(
            start_frame=self.start_spin.value(),
            end_frame=self.end_spin.value(),
            event_name=self.event_combo.currentText(),
            note=self.note_edit.text().strip()
        )

        # –ü—Ä–∏–º–µ–Ω—è–µ–º —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É –¥–ª—è undo/redo
        from ..utils.undo_redo import ModifyMarkerCommand
        command = ModifyMarkerCommand(
            self.controller.markers,
            self.marker_idx,
            old_marker,
            new_marker
        )
        from ..utils.undo_redo import UndoRedoManager
        self.controller.undo_redo.push_command(command)

        # –û–±–Ω–æ–≤–ª—è–µ–º UI
        self.controller.markers_changed.emit()
        self.controller.timeline_update.emit()

        super().accept()

===== settings_dialog.py =====
from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QTabWidget, QLabel,
    QComboBox, QDoubleSpinBox, QSpinBox, QPushButton, QColorDialog,
    QLineEdit, QCheckBox, QWidget, QMessageBox
)
from PySide6.QtGui import QColor
from enum import Enum
from ..utils.settings_manager import get_settings_manager
from .custom_event_dialog import CustomEventManagerDialog


class SettingsDialog(QDialog):
    """–û–∫–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —Å –≤–∫–ª–∞–¥–∫–∞–º–∏."""

    def __init__(self, controller, parent=None):
        super().__init__(parent)
        self.controller = controller
        self.settings_manager = get_settings_manager()
        
        self.setWindowTitle("Settings")
        self.setGeometry(200, 200, 500, 400)
        self.setup_ui()

    def setup_ui(self):
        """–°–æ–∑–¥–∞—Ç—å UI —Å –≤–∫–ª–∞–¥–∫–∞–º–∏."""
        layout = QVBoxLayout()
        
        # –í–∫–ª–∞–¥–∫–∏
        tabs = QTabWidget()
        
        # –í–∫–ª–∞–¥–∫–∞ 1: –†–µ–∂–∏–º —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏
        tabs.addTab(self._create_recording_mode_tab(), "Recording Mode")
        
        # –í–∫–ª–∞–¥–∫–∞ 2: –ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏
        tabs.addTab(self._create_hotkeys_tab(), "Hotkeys")
        
        # –í–∫–ª–∞–¥–∫–∞ 3: –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
        tabs.addTab(self._create_colors_tab(), "Colors")
        
        # –í–∫–ª–∞–¥–∫–∞ 4: –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        tabs.addTab(self._create_autosave_tab(), "Autosave")
        
        layout.addWidget(tabs)

        # –ö–Ω–æ–ø–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º–∏ —Å–æ–±—ã—Ç–∏—è–º–∏
        events_btn = QPushButton("üìù Manage Events")
        events_btn.clicked.connect(self._manage_events)
        layout.addWidget(events_btn)

        # –ö–Ω–æ–ø–∫–∏
        button_layout = QHBoxLayout()
        
        save_btn = QPushButton("üíæ Save")
        save_btn.clicked.connect(self.save_and_close)
        button_layout.addWidget(save_btn)
        
        cancel_btn = QPushButton("‚úï Cancel")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)
        
        layout.addLayout(button_layout)
        
        self.setLayout(layout)

    def _create_recording_mode_tab(self):
        """–í–∫–ª–∞–¥–∫–∞ —Ä–µ–∂–∏–º–∞ —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏ –æ—Ç—Ä–µ–∑–∫–æ–≤."""
        widget = QVBoxLayout()
        
        # –†–µ–∂–∏–º —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏
        widget.addWidget(QLabel("Recording Mode:"))
        self.mode_combo = QComboBox()
        self.mode_combo.addItems(["Dynamic (2 taps)", "Fixed Length (1 tap)"])
        mode_idx = 0 if self.controller.recording_mode.value == "dynamic" else 1
        self.mode_combo.setCurrentIndex(mode_idx)
        widget.addWidget(self.mode_combo)
        
        # –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –¥–ª–∏–Ω–∞
        widget.addWidget(QLabel("\nFixed Duration (seconds):"))
        self.fixed_duration_spin = QSpinBox()
        self.fixed_duration_spin.setRange(1, 120)
        self.fixed_duration_spin.setValue(int(self.controller.fixed_duration_sec))
        self.fixed_duration_spin.setSingleStep(5)
        widget.addWidget(self.fixed_duration_spin)
        
        # Pre-roll
        widget.addWidget(QLabel("\nPre-roll (seconds):"))
        self.pre_roll_spin = QDoubleSpinBox()
        self.pre_roll_spin.setRange(0.0, 10.0)
        self.pre_roll_spin.setValue(self.controller.pre_roll_sec)
        self.pre_roll_spin.setSingleStep(0.5)
        widget.addWidget(self.pre_roll_spin)
        
        # Post-roll
        widget.addWidget(QLabel("\nPost-roll (seconds):"))
        self.post_roll_spin = QDoubleSpinBox()
        self.post_roll_spin.setRange(0.0, 10.0)
        self.post_roll_spin.setValue(self.controller.post_roll_sec)
        self.post_roll_spin.setSingleStep(0.5)
        widget.addWidget(self.post_roll_spin)
        
        widget.addStretch()
        return self._wrap_widget(widget)

    def _create_hotkeys_tab(self):
        """–í–∫–ª–∞–¥–∫–∞ –≥–æ—Ä—è—á–∏—Ö –∫–ª–∞–≤–∏—à."""
        widget = QVBoxLayout()

        widget.addWidget(QLabel("Hotkeys Settings:"))
        widget.addWidget(QLabel("Hotkeys are managed in the 'Manage Events' dialog."))
        widget.addWidget(QLabel("Use the 'üìù Manage Events' button below to customize events and their shortcuts."))

        # –°—Ç–∞—Ç—É—Å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        info_text = """
Hotkey System:
‚Ä¢ A/D/S keys for quick event marking during video playback
‚Ä¢ Custom shortcuts for user-defined events
‚Ä¢ Works globally even when timeline or other controls are focused
‚Ä¢ Space bar for Play/Pause video
‚Ä¢ Ctrl+E for Export, Ctrl+S for Save Project
"""
        info_label = QLabel(info_text)
        info_label.setWordWrap(True)
        info_label.setStyleSheet("color: #cccccc; font-size: 11px;")
        widget.addWidget(info_label)

        widget.addStretch()
        return self._wrap_widget(widget)

    def _create_colors_tab(self):
        """–í–∫–ª–∞–¥–∫–∞ —Ü–≤–µ—Ç–æ–≤."""
        widget = QVBoxLayout()
        
        widget.addWidget(QLabel("Event Colors:"))
        
        self.color_buttons = {}
        colors = {
            'ATTACK': '#8b0000',
            'DEFENSE': '#000080',
            'SHIFT': '#006400',
        }
        
        for event_type, color_hex in colors.items():
            layout = QHBoxLayout()
            layout.addWidget(QLabel(event_type + ":"))
            
            btn = QPushButton()
            btn.setStyleSheet(f"background-color: {color_hex}; width: 100px;")
            btn.clicked.connect(lambda checked, e=event_type: self._choose_color(e))
            self.color_buttons[event_type] = (btn, color_hex)
            layout.addWidget(btn)
            widget.addLayout(layout)
        
        widget.addStretch()
        return self._wrap_widget(widget)

    def _create_autosave_tab(self):
        """–í–∫–ª–∞–¥–∫–∞ –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è."""
        widget = QVBoxLayout()
        
        # –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        widget.addWidget(QLabel("Autosave Settings:"))
        
        self.autosave_check = QCheckBox("Enable autosave")
        self.autosave_check.setChecked(self.settings_manager.load_autosave_enabled())
        widget.addWidget(self.autosave_check)

        # –ò–Ω—Ç–µ—Ä–≤–∞–ª
        widget.addWidget(QLabel("\nAutosave interval (minutes):"))
        self.autosave_interval_spin = QSpinBox()
        self.autosave_interval_spin.setRange(1, 60)
        self.autosave_interval_spin.setValue(self.settings_manager.load_autosave_interval())
        widget.addWidget(self.autosave_interval_spin)

        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        widget.addWidget(QLabel("\nMarkers are automatically saved to 'project.json'"))

        widget.addStretch()
        return self._wrap_widget(widget)

    def _wrap_widget(self, layout):
        """–û–±—ë—Ä—Ç–∫–∞ –¥–ª—è –≤–∫–ª–∞–¥–∫–∏."""
        from PySide6.QtWidgets import QWidget
        widget = QWidget()
        widget.setLayout(layout)
        return widget

    def _choose_color(self, event_type: str):
        """–í—ã–±—Ä–∞—Ç—å —Ü–≤–µ—Ç."""
        btn, current_color = self.color_buttons[event_type]
        color = QColorDialog.getColor(QColor(current_color), self, f"Choose color for {event_type}")
        if color.isValid():
            hex_color = color.name()
            btn.setStyleSheet(f"background-color: {hex_color}; width: 100px;")
            self.color_buttons[event_type] = (btn, hex_color)

    def save_and_close(self):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ –∑–∞–∫—Ä—ã—Ç—å."""
        # –†–µ–∂–∏–º —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏
        mode_str = "dynamic" if self.mode_combo.currentIndex() == 0 else "fixed_length"
        from ..core.video_controller import RecordingMode
        self.controller.set_recording_mode(RecordingMode(mode_str))

        # –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –¥–ª–∏–Ω–∞
        self.controller.set_fixed_duration(self.fixed_duration_spin.value())

        # Pre-roll –∏ Post-roll
        self.controller.set_pre_roll(self.pre_roll_spin.value())
        self.controller.set_post_roll(self.post_roll_spin.value())

        # –¶–≤–µ—Ç–∞ –¥–æ—Ä–æ–∂–µ–∫ (—Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ QSettings)
        colors = {}
        for event_type, (_, color_hex) in self.color_buttons.items():
            colors[event_type] = color_hex
        self.settings_manager.save_track_colors(colors)

        # –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        self.settings_manager.save_autosave_enabled(self.autosave_check.isChecked())
        self.settings_manager.save_autosave_interval(self.autosave_interval_spin.value())

        # –ü—Ä–∏–º–µ–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è - –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        self.settings_manager.sync()

        QMessageBox.information(self, "Settings Saved",
                               "Settings have been saved successfully.\n\n"
                               "Restart the application for some changes to take full effect.")

        self.accept()

    def _manage_events(self):
        """–û—Ç–∫—Ä—ã—Ç—å –¥–∏–∞–ª–æ–≥ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ–±—ã—Ç–∏—è–º–∏."""
        dialog = CustomEventManagerDialog(self)
        dialog.exec()


===== timeline.py =====
from PySide6.QtCore import Qt, QSize, QTimer, QRect
from PySide6.QtGui import QPainter, QColor, QFont, QPen
from PySide6.QtWidgets import QWidget
from typing import Optional


class TimelineWidget(QWidget):
    """–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π —Ç–∞–π–º–ª–∞–π–Ω (–∫–∞–∫ –≤ SportCode)."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.controller = None
        
        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
        self.track_height = 50
        self.header_height = 30
        self.pixels_per_second = 100
        self.zoom = 1.0
        self.scroll_x = 0
        
        # –ú–∏–≥–∞–Ω–∏–µ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏
        self.blink_timer = QTimer()
        self.blink_timer.timeout.connect(self._on_blink_tick)
        self.blink_visible = True
        self.blink_interval = 500  # –º—Å
        
        # –¶–≤–µ—Ç–∞ –¥–æ—Ä–æ–∂–µ–∫
        self.colors = {
            'ATTACK': QColor(139, 0, 0),      # –¢—ë–º–Ω–æ-–∫—Ä–∞—Å–Ω—ã–π
            'DEFENSE': QColor(0, 0, 128),     # –¢—ë–º–Ω–æ-—Å–∏–Ω–∏–π
            'SHIFT': QColor(0, 100, 0),       # –¢—ë–º–Ω–æ-–∑–µ–ª—ë–Ω—ã–π
            'PLAYHEAD': QColor(255, 255, 0),  # –ñ—ë–ª—Ç—ã–π
            'REC': QColor(255, 200, 0),       # –ñ—ë–ª—Ç–æ-–æ—Ä–∞–Ω–∂–µ–≤—ã–π
            'SEGMENT': QColor(255, 255, 255), # –ë–µ–ª—ã–π
        }
        
        self.setMinimumHeight(self.header_height + 3 * self.track_height)
        self.setStyleSheet("background-color: #1a1a1a; border: none;")
        self.setFocusPolicy(Qt.FocusPolicy.NoFocus)

    def set_controller(self, controller):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä –≤–∏–¥–µ–æ."""
        self.controller = controller
        if controller:
            controller.timeline_update.connect(self.update)
            controller.playback_time_changed.connect(lambda _: self.update())
            controller.markers_changed.connect(self.update)
            controller.recording_status_changed.connect(self._on_recording_status_changed)

    def _on_recording_status_changed(self, event_type: str, status: str):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–ø–∏—Å–∏."""
        if status == "Recording":
            self.blink_timer.start(self.blink_interval)
        elif status in ("Complete", "Fixed", "Cancelled"):
            self.blink_timer.stop()
            self.blink_visible = True
        self.update()

    def _on_blink_tick(self):
        """–ú–∏–≥–∞–Ω–∏–µ REC –ø—Ä–∏ –∑–∞–ø–∏—Å–∏."""
        self.blink_visible = not self.blink_visible
        self.update()

    def paintEvent(self, event):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ç–∞–π–º–ª–∞–π–Ω–∞."""
        if not self.controller or not self.controller.processor.cap:
            return
        
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # –§–æ–Ω
        painter.fillRect(self.rect(), QColor(26, 26, 26))
        
        # –†–∏—Å–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–π —à–∫–∞–ª—ã
        self._draw_timeline_header(painter)
        
        # –†–∏—Å–æ–≤–∞–Ω–∏–µ –¥–æ—Ä–æ–∂–µ–∫
        self._draw_tracks(painter)

    def _draw_timeline_header(self, painter: QPainter):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–π —à–∫–∞–ª—ã."""
        header_rect = QRect(0, 0, self.width(), self.header_height)
        painter.fillRect(header_rect, QColor(35, 35, 35))
        painter.drawLine(0, self.header_height - 1, self.width(), self.header_height - 1)
        
        # –†–∞—Å—á—ë—Ç –≤—Ä–µ–º–µ–Ω–∏
        total_frames = self.controller.get_total_frames()
        fps = self.controller.get_fps()
        total_time = total_frames / fps if fps > 0 else 0
        
        # –ú–µ—Ç–∫–∏ –≤—Ä–µ–º–µ–Ω–∏
        painter.setPen(QColor(150, 150, 150))
        painter.setFont(QFont("Arial", 8))
        
        pixels_per_sec_with_zoom = self.pixels_per_second * self.zoom
        time_step = 5  # –ú–µ—Ç–∫–∏ –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
        
        for sec in range(0, int(total_time) + time_step, time_step):
            x = sec * pixels_per_sec_with_zoom - self.scroll_x
            if 0 <= x <= self.width():
                painter.drawLine(int(x), self.header_height - 5, int(x), self.header_height)
                time_str = self._format_time(sec)
                painter.drawText(int(x) - 15, 10, 30, 15, Qt.AlignmentFlag.AlignCenter, time_str)

    def _draw_tracks(self, painter: QPainter):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –¥–æ—Ä–æ–∂–µ–∫ —Å –æ—Ç—Ä–µ–∑–∫–∞–º–∏."""
        tracks = ['ATTACK', 'DEFENSE', 'SHIFT']
        
        for idx, track_name in enumerate(tracks):
            track_y = self.header_height + idx * self.track_height
            track_rect = QRect(0, track_y, self.width(), self.track_height)
            
            # –§–æ–Ω –¥–æ—Ä–æ–∂–∫–∏
            color = self.colors[track_name]
            bg_color = QColor(color)
            bg_color.setAlpha(30)
            painter.fillRect(track_rect, bg_color)
            painter.drawRect(track_rect)
            
            # –ú–µ—Ç–∫–∞ –¥–æ—Ä–æ–∂–∫–∏ (—Å–ª–µ–≤–∞)
            label_rect = QRect(5, track_y, 80, self.track_height)
            painter.setPen(color)
            painter.setFont(QFont("Arial", 9, QFont.Weight.Bold))
            painter.drawText(label_rect, Qt.AlignmentFlag.AlignVCenter, track_name)
        
        # –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –æ—Ç—Ä–µ–∑–∫–æ–≤
        self._draw_segments(painter, tracks)
        
        # –û—Ç—Ä–∏—Å–æ–≤–∫–∞ playhead
        self._draw_playhead(painter)
        
        # –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ä–∞—Å—Ç—É—â–µ–≥–æ –æ—Ç—Ä–µ–∑–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏
        if self.controller.is_recording:
            self._draw_recording_indicator(painter, tracks)

    def _draw_segments(self, painter: QPainter, tracks: list):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã—Ö –æ—Ç—Ä–µ–∑–∫–æ–≤."""
        fps = self.controller.get_fps()
        if fps == 0:
            return
        
        pixels_per_sec = self.pixels_per_second * self.zoom
        
        for marker in self.controller.markers:
            track_idx = tracks.index(marker.type.name)
            track_y = self.header_height + track_idx * self.track_height
            
            # –ü–æ–∑–∏—Ü–∏–∏ –≤ –ø–∏–∫—Å–µ–ª—è—Ö
            start_x = (marker.start_frame / fps) * pixels_per_sec - self.scroll_x
            end_x = (marker.end_frame / fps) * pixels_per_sec - self.scroll_x
            width = max(2, end_x - start_x)
            
            # –†–∏—Å–æ–≤–∞–Ω–∏–µ –ø–æ–ª–æ—Å–∫–∏
            segment_rect = QRect(int(start_x), track_y + 5, int(width), self.track_height - 10)
            color = self.colors[marker.type.name]
            painter.fillRect(segment_rect, self.colors['SEGMENT'])
            painter.setPen(color)
            painter.drawRect(segment_rect)

    def _draw_playhead(self, painter: QPainter):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ playhead (–∂—ë–ª—Ç–∞—è –ª–∏–Ω–∏—è)."""
        fps = self.controller.get_fps()
        current_frame = self.controller.get_current_frame_idx()
        
        if fps == 0:
            return
        
        pixels_per_sec = self.pixels_per_second * self.zoom
        playhead_x = (current_frame / fps) * pixels_per_sec - self.scroll_x
        
        painter.setPen(QPen(self.colors['PLAYHEAD'], 2))
        painter.drawLine(int(playhead_x), self.header_height, int(playhead_x), self.height())

    def _draw_recording_indicator(self, painter: QPainter, tracks: list):
        """–û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ä–∞—Å—Ç—É—â–µ–≥–æ –æ—Ç—Ä–µ–∑–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏."""
        if not self.controller.recording_event_type or self.controller.recording_start_frame is None:
            return
        
        fps = self.controller.get_fps()
        if fps == 0:
            return
        
        pixels_per_sec = self.pixels_per_second * self.zoom
        track_idx = tracks.index(self.controller.recording_event_type.name)
        track_y = self.header_height + track_idx * self.track_height
        
        # –ù–∞—á–∞–ª–æ –∏ –∫–æ–Ω–µ—Ü —Ç–µ–∫—É—â–µ–π –∑–∞–ø–∏—Å–∏
        current_frame = self.controller.get_current_frame_idx()
        start_x = (self.controller.recording_start_frame / fps) * pixels_per_sec - self.scroll_x
        end_x = (current_frame / fps) * pixels_per_sec - self.scroll_x
        width = max(2, end_x - start_x)
        
        # –†–∏—Å–æ–≤–∞–Ω–∏–µ —Ä–∞—Å—Ç—É—â–µ–π –ø–æ–ª–æ—Å–∫–∏
        rec_rect = QRect(int(start_x), track_y + 5, int(width), self.track_height - 10)
        painter.fillRect(rec_rect, self.colors['REC'])
        
        # –ú–∏–≥–∞—é—â–∏–π —Ç–µ–∫—Å—Ç REC
        if self.blink_visible:
            painter.setPen(QColor(255, 0, 0))
            painter.setFont(QFont("Arial", 10, QFont.Weight.Bold))
            painter.drawText(rec_rect, Qt.AlignmentFlag.AlignCenter, "üî¥ REC")

    def _format_time(self, seconds: int) -> str:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–µ–∫—É–Ω–¥—ã –≤ MM:SS."""
        minutes = seconds // 60
        secs = seconds % 60
        return f"{minutes:02d}:{secs:02d}"

    def mousePressEvent(self, event):
        """–ö–ª–∏–∫ –Ω–∞ —Ç–∞–π–º–ª–∞–π–Ω = seek."""
        if not self.controller or not self.controller.processor.cap:
            return
        
        # –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–ª–∏–∫ –ø–æ –¥–æ—Ä–æ–∂–∫–µ
        if event.y() < self.header_height:
            return
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å x –≤ —Ñ—Ä–µ–π–º
        fps = self.controller.get_fps()
        if fps == 0:
            return
        
        pixels_per_sec = self.pixels_per_second * self.zoom
        seconds = (event.x() + self.scroll_x) / pixels_per_sec
        frame_idx = int(seconds * fps)
        
        self.controller.seek_frame(frame_idx)

    def wheelEvent(self, event):
        """–ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–ª–µ—Å–æ–º –º—ã—à–∏ (Ctrl+Wheel)."""
        if event.modifiers() != Qt.KeyboardModifier.ControlModifier:
            return
        
        # Zoom
        delta = event.angleDelta().y()
        if delta > 0:
            self.zoom = min(self.zoom * 1.2, 10.0)
        else:
            self.zoom = max(self.zoom / 1.2, 1.0)
        
        self.update()

    def sizeHint(self) -> QSize:
        """–†–∞–∑–º–µ—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é."""
        return QSize(800, self.header_height + 3 * self.track_height)


===== timeline_graphics.py =====
# ui/timeline_graphics.py
# –§–∏–Ω–∞–ª—å–Ω–∞—è —Å—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è ‚Äî –≤—Å—ë —Ä–∞–±–æ—Ç–∞–µ—Ç –∏–¥–µ–∞–ª—å–Ω–æ

from PySide6.QtWidgets import (
    QGraphicsRectItem, QGraphicsLineItem, QGraphicsScene, QGraphicsView,
    QGraphicsTextItem, QScrollArea, QWidget, QVBoxLayout
)
from PySide6.QtCore import Qt, QRectF
from PySide6.QtGui import QPen, QBrush, QColor, QFont, QPainter
from ..utils.custom_events import get_custom_event_manager


class SegmentGraphicsItem(QGraphicsRectItem):
    def __init__(self, marker, timeline_scene):
        super().__init__()
        self.marker = marker
        self.timeline_scene = timeline_scene
        self.setAcceptHoverEvents(True)
        self.setFlag(QGraphicsRectItem.ItemIsSelectable, True)

        event_manager = get_custom_event_manager()
        event = event_manager.get_event(marker.event_name)
        self.event_color = QColor(event.color) if event else QColor("#888888")

        self.setBrush(QBrush(QColor(255, 255, 255, 230)))
        self.setPen(QPen(self.event_color, 4, Qt.SolidLine, Qt.RoundCap))

        self.text_item = QGraphicsTextItem(marker.event_name, self)
        self.text_item.setDefaultTextColor(QColor("#000000"))
        self.text_item.setFont(QFont("Segoe UI", 10, QFont.Bold))

    def paint(self, painter: QPainter, *args):
        super().paint(painter, *args)
        rect = self.rect()
        text_rect = self.text_item.boundingRect()
        x = rect.width() / 2 - text_rect.width() / 2
        y = rect.height() / 2 - text_rect.height() / 2
        self.text_item.setPos(x, y)

    def hoverEnterEvent(self, event):
        self.setPen(QPen(self.event_color.lighter(140), 6))
        self.setBrush(QBrush(QColor(255, 255, 255, 255)))

    def hoverLeaveEvent(self, event):
        self.setPen(QPen(self.event_color, 4))
        self.setBrush(QBrush(QColor(255, 255, 255, 230)))

    def mouseDoubleClickEvent(self, event):
        if self.timeline_scene.main_window:
            try:
                idx = self.timeline_scene.controller.markers.index(self.marker)
                self.timeline_scene.main_window.open_segment_editor(idx)
            except ValueError:
                pass


class TimelineGraphicsScene(QGraphicsScene):
    def __init__(self, controller):
        super().__init__()
        self.controller = controller
        self.main_window = None
        self.pixels_per_frame = 0.8
        self.track_height = 60
        self.header_height = 40

        # Playhead —Å–æ–∑–¥–∞—ë–º –æ–¥–∏–Ω —Ä–∞–∑ –∏ –±–æ–ª—å—à–µ –ù–ò–ö–û–ì–î–ê –Ω–µ —É–¥–∞–ª—è–µ–º!
        self.playhead = QGraphicsLineItem()
        self.playhead.setPen(QPen(QColor("#FFFF00"), 4, Qt.SolidLine, Qt.RoundCap))
        self.playhead.setZValue(1000)
        self.addItem(self.playhead)  # –¥–æ–±–∞–≤–ª—è–µ–º –Ω–∞–≤—Å–µ–≥–¥–∞

        self.rebuild()  # –ø–µ—Ä–≤—ã–π —Ä–µ–Ω–¥–µ—Ä

    def rebuild(self):
        total_frames = max(self.controller.get_total_frames(), 1)
        events = get_custom_event_manager().get_all_events()

        # –û—á–∏—â–∞–µ–º –≤—Å—ë –ö–†–û–ú–ï playhead
        for item in self.items():
            if item is not self.playhead:
                self.removeItem(item)

        scene_width = total_frames * self.pixels_per_frame + 300
        scene_height = len(events) * self.track_height + self.header_height + 50
        self.setSceneRect(0, 0, scene_width, scene_height)

        track_bg = QColor("#0d1b2a")

        for i, event in enumerate(events):
            y = i * self.track_height

            # –§–æ–Ω –¥–æ—Ä–æ–∂–∫–∏
            self.addRect(0, y, scene_width, self.track_height,
                         QPen(Qt.NoPen), QBrush(track_bg))

            # –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å–æ–±—ã—Ç–∏—è
            header = self.addRect(0, y, 140, self.track_height,
                                QPen(QColor("#1b263b")), QBrush(QColor(event.color)))
            text = self.addText(event.name)
            text.setDefaultTextColor(Qt.white)
            text.setFont(QFont("Segoe UI", 11, QFont.Bold))
            text.setPos(10, y + 15)

            # –°–µ–≥–º–µ–Ω—Ç—ã
            for marker in self.controller.markers:
                if marker.event_name != event.name:
                    continue
                x = marker.start_frame * self.pixels_per_frame
                w = (marker.end_frame - marker.start_frame + 1) * self.pixels_per_frame
                if w < 10: w = 10

                segment = SegmentGraphicsItem(marker, self)
                segment.setRect(x + 150, y + 8, w, self.track_height - 16)
                self.addItem(segment)

        self.update_playhead(self.controller.get_current_frame_idx())

    def update_playhead(self, frame_idx: int):
        if frame_idx < 0:
            return
        x = frame_idx * self.pixels_per_frame + 150
        self.playhead.setLine(x, 0, x, self.sceneRect().height())


class TimelineWidget(QWidget):
    def __init__(self, controller):
        super().__init__()
        self.controller = controller

        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self.view = QGraphicsView()
        self.view.setRenderHint(QPainter.Antialiasing)
        self.view.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        self.view.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.view.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.view.setAlignment(Qt.AlignLeft | Qt.AlignTop)

        self.scene = TimelineGraphicsScene(controller)
        self.scene.main_window = self  # –¥–ª—è –¥–≤–æ–π–Ω–æ–≥–æ –∫–ª–∏–∫–∞
        self.view.setScene(self.scene)

        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setWidget(self.view)
        layout.addWidget(scroll)

        # === –ü–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è ===
        controller.markers_changed.connect(self.scene.rebuild)
        controller.playback_time_changed.connect(lambda f: self.scene.update_playhead(f))
        controller.timeline_update.connect(lambda: self.scene.update_playhead(self.controller.get_current_frame_idx()))
        get_custom_event_manager().events_changed.connect(self.scene.rebuild)

        # –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
        self.scale_factor = 1.0

    def wheelEvent(self, event):
        if event.modifiers() & Qt.ControlModifier:
            factor = 1.25 if event.angleDelta().y() > 0 else 0.8
            self.scale_factor *= factor
            self.scene.pixels_per_frame *= factor
            self.scene.rebuild()

            # –ê–≤—Ç–æ—Å–∫—Ä–æ–ª–ª –∫ –ø–ª–µ–π—Ö–µ–¥—É
            current_x = self.controller.get_current_frame_idx() * self.scene.pixels_per_frame + 150
            self.view.horizontalScrollBar().setValue(int(current_x - self.view.width() // 2))
        else:
            super().wheelEvent(event)

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            pos = self.view.mapToScene(self.view.mapFrom(self, event.pos()))
            frame = int((pos.x() - 150) / self.scene.pixels_per_frame)
            frame = max(0, min(frame, self.controller.get_total_frames() - 1))
            self.controller.seek_frame(frame)
        super().mousePressEvent(event)

===== video_window.py =====
# ui/video_window.py
from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QPushButton, QSlider, QHBoxLayout
from PySide6.QtCore import Qt, QTimer
from PySide6.QtGui import QImage, QPixmap, QKeySequence, QShortcut
import cv2


class VideoWindow(QWidget):
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.controller = main_window.controller
        self.setWindowTitle("–ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä")
        self.setWindowFlags(Qt.Window | Qt.WindowCloseButtonHint)
        self.resize(1200, 700)

        self.current_frame = 0
        self.playing = False

        self.setup_ui()
        self.setup_shortcuts()
        self.timer = QTimer()
        self.timer.timeout.connect(self.next_frame)

    def setup_ui(self):
        layout = QVBoxLayout(self)

        # –í–∏–¥–µ–æ
        self.video_label = QLabel()
        self.video_label.setAlignment(Qt.AlignCenter)
        self.video_label.setStyleSheet("background-color: black;")
        self.video_label.setMinimumSize(640, 360)
        layout.addWidget(self.video_label)

        # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        controls = QHBoxLayout()
        controls.addStretch()

        self.play_btn = QPushButton("Play")
        self.play_btn.clicked.connect(self.toggle_playback)
        controls.addWidget(self.play_btn)

        self.slider = QSlider(Qt.Horizontal)
        self.slider.setRange(0, 1000)
        self.slider.sliderMoved.connect(self.seek_from_slider)
        controls.addWidget(self.slider, stretch=1)

        controls.addStretch()
        layout.addLayout(controls)

        # –ö–Ω–æ–ø–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è
        close_btn = QPushButton("–ó–∞–∫—Ä—ã—Ç—å")
        close_btn.clicked.connect(self.close)
        close_layout = QHBoxLayout()
        close_layout.addStretch()
        close_layout.addWidget(close_btn)
        close_layout.addStretch()
        layout.addLayout(close_layout)

        self.update_frame()

    def setup_shortcuts(self):
        QShortcut(QKeySequence("Space"), self, self.toggle_playback)
        QShortcut(QKeySequence("Esc"), self, self.close)
        QShortcut(QKeySequence("Left"), self, lambda: self.seek_relative(-30))
        QShortcut(QKeySequence("Right"), self, lambda: self.seek_relative(30))

    def toggle_playback(self):
        self.playing = not self.playing
        self.play_btn.setText("Pause" if self.playing else "Play")
        if self.playing:
            self.timer.start(33)  # ~30 fps
        else:
            self.timer.stop()

    def next_frame(self):
        if not self.controller.processor.cap:
            return
        ret, frame = self.controller.processor.cap.read()
        if not ret:
            self.playing = False
            self.play_btn.setText("Play")
            self.timer.stop()
            return
        self.current_frame = int(self.controller.processor.cap.get(cv2.CAP_PROP_POS_FRAMES))
        self.display_frame(frame)
        self.update_slider()

    def display_frame(self, frame_bgr):
        if frame_bgr is None:
            return
        frame_rgb = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2RGB)
        h, w, ch = frame_rgb.shape
        bytes_per_line = ch * w
        q_img = QImage(frame_rgb.data, w, h, bytes_per_line, QImage.Format_RGB888)
        pixmap = QPixmap.fromImage(q_img)
        scaled = pixmap.scaled(self.video_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.video_label.setPixmap(scaled)

    def update_frame(self):
        frame = self.controller.processor.get_frame(self.current_frame)
        if frame is not None:
            self.display_frame(frame)

    def update_slider(self):
        if self.controller.processor.total_frames > 0:
            pos = self.current_frame / self.controller.processor.total_frames
            self.slider.blockSignals(True)
            self.slider.setValue(int(pos * 1000))
            self.slider.blockSignals(False)

    def seek_from_slider(self, value):
        if self.controller.processor.total_frames > 0:
            frame = int(value / 1000 * self.controller.processor.total_frames)
            self.seek_to_frame(frame)

    def seek_to_frame(self, frame):
        self.current_frame = max(0, min(frame, self.controller.processor.total_frames - 1))
        self.controller.processor.seek(self.current_frame)
        self.update_frame()
        self.update_slider()

    def seek_relative(self, frames):
        self.seek_to_frame(self.current_frame + frames)

    def closeEvent(self, event):
        self.timer.stop()
        event.accept()

===== autosave.py =====
"""
Autosave and Recovery System - —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞ –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç + –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –∫—Ä–∞—à–µ.
"""

import os
import json
from pathlib import Path
from datetime import datetime
from PySide6.QtCore import QTimer, QObject, Signal
from typing import Optional
from ..core.project_manager import ProjectManager


class AutosaveManager(QObject):
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è."""
    
    autosave_triggered = Signal()  # –°–∏–≥–Ω–∞–ª –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º
    autosave_completed = Signal(bool, str)  # (success, message)
    recovery_available = Signal(str)  # path to recovery file
    
    AUTOSAVE_INTERVAL_MS = 5 * 60 * 1000  # 5 –º–∏–Ω—É—Ç
    RECOVERY_DIR = Path.home() / ".hockey_editor" / "recovery"
    RECOVERY_MANIFEST = RECOVERY_DIR / "manifest.json"
    
    def __init__(self, controller):
        super().__init__()
        self.controller = controller
        self.autosave_enabled = True
        self.autosave_timer = QTimer()
        self.autosave_timer.timeout.connect(self._on_autosave_tick)
        self.last_autosave_path: Optional[str] = None
        
        # –°–æ–∑–¥–∞—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
        self.RECOVERY_DIR.mkdir(parents=True, exist_ok=True)
        
        # –ó–∞–≥—Ä—É–∑–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        from ..utils.settings_manager import get_settings_manager
        settings = get_settings_manager()
        self.autosave_interval = settings.load_autosave_interval()

    def start(self):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ."""
        if self.autosave_enabled:
            self.autosave_timer.start(self.AUTOSAVE_INTERVAL_MS)

    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ."""
        self.autosave_timer.stop()

    def _on_autosave_tick(self):
        """–¢–∞–π–º–µ—Ä –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è."""
        if self.controller.processor.path:
            self.perform_autosave()

    def perform_autosave(self) -> bool:
        """–í—ã–ø–æ–ª–Ω–∏—Ç—å –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ."""
        try:
            self.autosave_triggered.emit()
            
            # –°–æ–∑–¥–∞—Ç—å –∏–º—è —Ñ–∞–π–ª–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            recovery_path = self.RECOVERY_DIR / f"project_{timestamp}.hep"
            
            # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–µ–∫—Ç
            success = self.controller.save_project(str(recovery_path))
            
            if success:
                self.last_autosave_path = str(recovery_path)
                self._update_recovery_manifest(str(recovery_path))
                self.autosave_completed.emit(True, f"Autosaved at {datetime.now().strftime('%H:%M:%S')}")
                return True
            else:
                self.autosave_completed.emit(False, "Autosave failed")
                return False
        except Exception as e:
            self.autosave_completed.emit(False, f"Autosave error: {str(e)}")
            return False

    def _update_recovery_manifest(self, project_path: str):
        """–û–±–Ω–æ–≤–∏—Ç—å manifest —Ñ–∞–π–ª –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è."""
        try:
            manifest = {"recovery_files": [], "last_modified": datetime.now().isoformat()}
            
            # –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç–∞—Ä—ã–π manifest –µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            if self.RECOVERY_MANIFEST.exists():
                with open(self.RECOVERY_MANIFEST, 'r') as f:
                    manifest = json.load(f)
            
            # –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π —Ñ–∞–π–ª
            manifest["recovery_files"].append({
                "path": project_path,
                "timestamp": datetime.now().isoformat(),
                "size": os.path.getsize(project_path)
            })
            
            # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π manifest (–º–∞–∫—Å–∏–º—É–º 10 —Ñ–∞–π–ª–æ–≤)
            if len(manifest["recovery_files"]) > 10:
                old_file = manifest["recovery_files"].pop(0)
                try:
                    Path(old_file["path"]).unlink()  # –£–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–π —Ñ–∞–π–ª
                except:
                    pass
            
            manifest["last_modified"] = datetime.now().isoformat()
            
            with open(self.RECOVERY_MANIFEST, 'w') as f:
                json.dump(manifest, f, indent=2)
        except Exception as e:
            print(f"Error updating recovery manifest: {e}")

    @staticmethod
    def check_recovery() -> Optional[str]:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞–ª–∏—á–∏–µ —Ñ–∞–π–ª–æ–≤ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è."""
        manifest_path = AutosaveManager.RECOVERY_DIR / "manifest.json"
        
        if not manifest_path.exists():
            return None
        
        try:
            with open(manifest_path, 'r') as f:
                manifest = json.load(f)
            
            recovery_files = manifest.get("recovery_files", [])
            if recovery_files:
                # –í–µ—Ä–Ω—É—Ç—å —Å–∞–º—ã–π –Ω–æ–≤—ã–π —Ñ–∞–π–ª –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
                latest = recovery_files[-1]
                path = latest.get("path")
                if path and Path(path).exists():
                    return path
        except Exception as e:
            print(f"Error checking recovery: {e}")
        
        return None

    @staticmethod
    def clear_recovery():
        """–û—á–∏—Å—Ç–∏—Ç—å —Ñ–∞–π–ª—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è."""
        try:
            manifest_path = AutosaveManager.RECOVERY_DIR / "manifest.json"
            
            if manifest_path.exists():
                with open(manifest_path, 'r') as f:
                    manifest = json.load(f)
                
                # –£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ñ–∞–π–ª—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
                for recovery_file in manifest.get("recovery_files", []):
                    try:
                        Path(recovery_file.get("path")).unlink()
                    except:
                        pass
                
                # –£–¥–∞–ª–∏—Ç—å manifest
                manifest_path.unlink()
        except Exception as e:
            print(f"Error clearing recovery: {e}")

    @staticmethod
    def set_autosave_interval(seconds: int):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è."""
        from ..utils.settings_manager import get_settings_manager
        settings = get_settings_manager()
        settings.save_autosave_interval(seconds)


===== custom_events.py =====
"""
Custom event types manager for user-defined event categories.

Allows users to define their own event types (Attack, Defense, Shift, etc.)
with custom names and colors. Events are stored in QSettings and used
throughout the application for marker categorization.
"""

from typing import Dict, List, Optional
from dataclasses import dataclass
from PySide6.QtCore import Signal, QObject
from PySide6.QtGui import QColor
from .settings_manager import get_settings_manager


@dataclass
class CustomEventType:
    """Represents a custom event type with metadata."""
    
    name: str
    color: str  # Hex color (e.g., "#FF0000")
    shortcut: str = ""  # Keyboard shortcut (e.g., "A", "Ctrl+X")
    description: str = ""
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization."""
        return {
            'name': self.name,
            'color': self.color,
            'shortcut': self.shortcut,
            'description': self.description
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'CustomEventType':
        """Create from dictionary (deserialization)."""
        return cls(
            name=data.get('name', ''),
            color=data.get('color', '#CCCCCC'),
            shortcut=data.get('shortcut', ''),
            description=data.get('description', '')
        )
    
    def get_qcolor(self) -> QColor:
        """Get Qt color object."""
        color = QColor(self.color)
        return color if color.isValid() else QColor('#CCCCCC')


class CustomEventManager(QObject):
    """Manages user-defined event types with persistence."""

    # –°–∏–≥–Ω–∞–ª –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å–æ–±—ã—Ç–∏–π - –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è UI
    events_changed = Signal()

    # Default event types (always available)
    DEFAULT_EVENTS = [
        CustomEventType(name='Attack', color='#EF5350', shortcut='A', description='Offensive play'),
        CustomEventType(name='Defense', color='#42A5F5', shortcut='D', description='Defensive play'),
        CustomEventType(name='Shift', color='#66BB6A', shortcut='S', description='Line change/shift'),
    ]
    
    def __init__(self):
        """Initialize manager and load settings."""
        super().__init__()  # Initialize QObject base class
        self.settings = get_settings_manager()
        self._custom_events: Dict[str, CustomEventType] = {}
        self._load_events()
    
    def _load_events(self) -> None:
        """Load custom events from settings."""
        events_data = self.settings.load_custom_events()
        self._custom_events = {}
        
        # Load from settings
        for event_dict in events_data:
            event = CustomEventType.from_dict(event_dict)
            self._custom_events[event.name] = event
        
        # Ensure defaults exist (in case not in settings)
        for default_event in self.DEFAULT_EVENTS:
            if default_event.name not in self._custom_events:
                self._custom_events[default_event.name] = default_event
    
    def get_all_events(self) -> List[CustomEventType]:
        """Get all event types (sorted by name)."""
        return sorted(self._custom_events.values(), key=lambda e: e.name)
    
    def get_event(self, name: str) -> Optional[CustomEventType]:
        """Get specific event type by name."""
        return self._custom_events.get(name)
    
    def add_event(self, event: CustomEventType) -> bool:
        """Add new custom event. Returns False if name already exists."""
        if event.name in self._custom_events:
            return False
        
        # Validate color
        if not event.get_qcolor().isValid():
            return False
        
        self._custom_events[event.name] = event
        self._save_events()
        return True
    
    def update_event(self, old_name: str, new_event: CustomEventType) -> bool:
        """Update existing event. Returns False if new name already exists (and differs from old)."""
        if old_name not in self._custom_events:
            return False
        
        # Check if trying to rename to existing name
        if old_name != new_event.name and new_event.name in self._custom_events:
            return False
        
        # Validate color
        if not new_event.get_qcolor().isValid():
            return False
        
        # Remove old entry if renaming
        if old_name != new_event.name:
            del self._custom_events[old_name]
        
        self._custom_events[new_event.name] = new_event
        self._save_events()
        return True
    
    def delete_event(self, name: str) -> bool:
        """Delete custom event. Cannot delete default events."""
        if name not in self._custom_events:
            return False
        
        # Protect default events
        default_names = {e.name for e in self.DEFAULT_EVENTS}
        if name in default_names:
            return False
        
        del self._custom_events[name]
        self._save_events()
        return True
    
    def reset_to_defaults(self) -> None:
        """Reset all events to defaults."""
        self._custom_events = {e.name: e for e in self.DEFAULT_EVENTS}
        self._save_events()
    
    def _save_events(self) -> None:
        """Save custom events to settings."""
        events_data = [event.to_dict() for event in self.get_all_events()]
        self.settings.save_custom_events(events_data)
        self.events_changed.emit()  # –£–≤–µ–¥–æ–º–∏—Ç—å UI –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö

    def get_event_by_hotkey(self, hotkey: str) -> Optional[CustomEventType]:
        """Get event by keyboard shortcut."""
        for event in self._custom_events.values():
            if event.shortcut.upper() == hotkey.upper():
                return event
        return None
    
    def get_event_color(self, name: str) -> QColor:
        """Get color for event type (or gray if not found)."""
        event = self.get_event(name)
        if event:
            return event.get_qcolor()
        return QColor('#CCCCCC')  # Gray fallback
    
    def get_event_hotkey(self, name: str) -> str:
        """Get keyboard shortcut for event type."""
        event = self.get_event(name)
        return event.shortcut if event else ""


# Global instance
_manager: Optional[CustomEventManager] = None


def get_custom_event_manager() -> CustomEventManager:
    """Get or create global CustomEventManager instance."""
    global _manager
    if _manager is None:
        _manager = CustomEventManager()
    return _manager


def reset_custom_event_manager() -> None:
    """Reset global manager (for testing)."""
    global _manager
    _manager = None


===== settings_manager.py =====
"""
SettingsManager - –∫–ª–∞—Å—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤—Å–µ–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ —á–µ—Ä–µ–∑ QSettings.
–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏ –∑–∞–≥—Ä—É–∂–∞–µ—Ç: –≥–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏, —Ä–µ–∂–∏–º—ã, —Ü–≤–µ—Ç–∞, —Ä–∞–∑–º–µ—Ä –æ–∫–Ω–∞, etc.
"""

from PySide6.QtCore import QSettings
from typing import Dict, Tuple, Optional
from enum import Enum


class SettingsManager:
    """
    –ú–µ–Ω–µ–¥–∂–µ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–∫ –Ω–∞ –æ—Å–Ω–æ–≤–µ QSettings (—Ä–µ–µ—Å—Ç—Ä Windows / –∫–æ–Ω—Ñ–∏–≥ Linux).
    –û—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω—ã –ø–æ –≥—Ä—É–ø–ø–∞–º: hotkeys, ui, recording, colors, autosave.
    """
    
    def __init__(self, org: str = "HockeyEditorPro", app: str = "HockeyEditor"):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å QSettings."""
        self.settings = QSettings(org, app)
    
    # ============= –ì–û–†–Ø–ß–ò–ï –ö–õ–ê–í–ò–®–ò =============
    
    def save_hotkeys(self, hotkeys: Dict[str, str]) -> None:
        """
        –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≥–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏.
        –ü—Ä–∏–º–µ—Ä: {'ATTACK': 'A', 'DEFENSE': 'D', 'SHIFT': 'S'}
        """
        self.settings.beginGroup("hotkeys")
        for event_type, key in hotkeys.items():
            self.settings.setValue(event_type, key)
        self.settings.endGroup()
    
    def load_hotkeys(self) -> Dict[str, str]:
        """
        –ó–∞–≥—Ä—É–∑–∏—Ç—å –≥–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ, –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.
        """
        default = {'ATTACK': 'A', 'DEFENSE': 'D', 'SHIFT': 'S'}
        self.settings.beginGroup("hotkeys")
        hotkeys = {k: self.settings.value(k, v) for k, v in default.items()}
        self.settings.endGroup()
        return hotkeys
    
    # ============= –†–ï–ñ–ò–ú –†–ê–°–°–¢–ê–ù–û–í–ö–ò =============
    
    def save_recording_mode(self, mode: str) -> None:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∂–∏–º —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏: 'dynamic' –∏–ª–∏ 'fixed_length'."""
        self.settings.setValue("recording/mode", mode)
    
    def load_recording_mode(self) -> str:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ä–µ–∂–∏–º —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 'dynamic')."""
        return self.settings.value("recording/mode", "dynamic")
    
    def save_fixed_duration(self, seconds: int) -> None:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—É—é –¥–ª–∏–Ω—É –æ—Ç—Ä–µ–∑–∫–∞ (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)."""
        self.settings.setValue("recording/fixed_duration_sec", seconds)
    
    def load_fixed_duration(self) -> int:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—É—é –¥–ª–∏–Ω—É –æ—Ç—Ä–µ–∑–∫–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10)."""
        return int(self.settings.value("recording/fixed_duration_sec", 10))
    
    def save_pre_roll(self, seconds: float) -> None:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—Ç–∫–∞—Ç –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –æ—Ç—Ä–µ–∑–∫–∞ (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)."""
        self.settings.setValue("recording/pre_roll_sec", seconds)
    
    def load_pre_roll(self) -> float:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –æ—Ç–∫–∞—Ç –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –æ—Ç—Ä–µ–∑–∫–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 3.0)."""
        return float(self.settings.value("recording/pre_roll_sec", 3.0))
    
    def save_post_roll(self, seconds: float) -> None:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω–µ—Ü –æ—Ç—Ä–µ–∑–∫–∞ (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)."""
        self.settings.setValue("recording/post_roll_sec", seconds)
    
    def load_post_roll(self) -> float:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω–µ—Ü –æ—Ç—Ä–µ–∑–∫–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 0.0)."""
        return float(self.settings.value("recording/post_roll_sec", 0.0))
    
    # ============= –¶–í–ï–¢–ê –î–û–†–û–ñ–ï–ö =============
    
    def save_track_colors(self, colors: Dict[str, str]) -> None:
        """
        –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ü–≤–µ—Ç–∞ –¥–æ—Ä–æ–∂–µ–∫.
        –ü—Ä–∏–º–µ—Ä: {'ATTACK': '#8b0000', 'DEFENSE': '#000080', 'SHIFT': '#006400'}
        """
        self.settings.beginGroup("colors")
        for track, hex_color in colors.items():
            self.settings.setValue(track, hex_color)
        self.settings.endGroup()
    
    def load_track_colors(self) -> Dict[str, str]:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ü–≤–µ—Ç–∞ –¥–æ—Ä–æ–∂–µ–∫ (–≤–µ—Ä–Ω—ë—Ç –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ, –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã)."""
        default = {
            'ATTACK': '#8b0000',    # –¢—ë–º–Ω–æ-–∫—Ä–∞—Å–Ω—ã–π
            'DEFENSE': '#000080',   # –¢—ë–º–Ω–æ-—Å–∏–Ω–∏–π
            'SHIFT': '#006400',     # –¢—ë–º–Ω–æ-–∑–µ–ª—ë–Ω—ã–π
        }
        self.settings.beginGroup("colors")
        colors = {k: self.settings.value(k, v) for k, v in default.items()}
        self.settings.endGroup()
        return colors
    
    # ============= –†–ê–ó–ú–ï–† –ò –ü–û–ó–ò–¶–ò–Ø –û–ö–ù–ê =============
    
    def save_window_geometry(self, x: int, y: int, width: int, height: int) -> None:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–∞–∑–º–µ—Ä –∏ –ø–æ–∑–∏—Ü–∏—é –≥–ª–∞–≤–Ω–æ–≥–æ –æ–∫–Ω–∞."""
        self.settings.beginGroup("ui")
        self.settings.setValue("window_x", x)
        self.settings.setValue("window_y", y)
        self.settings.setValue("window_width", width)
        self.settings.setValue("window_height", height)
        self.settings.endGroup()
    
    def load_window_geometry(self) -> Tuple[int, int, int, int]:
        """
        –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ä–∞–∑–º–µ—Ä –∏ –ø–æ–∑–∏—Ü–∏—é –æ–∫–Ω–∞.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (x, y, width, height) –∏–ª–∏ –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è.
        """
        self.settings.beginGroup("ui")
        x = int(self.settings.value("window_x", 0))
        y = int(self.settings.value("window_y", 0))
        width = int(self.settings.value("window_width", 1800))
        height = int(self.settings.value("window_height", 1000))
        self.settings.endGroup()
        return x, y, width, height
    
    # ============= –ê–í–¢–û–°–û–•–†–ê–ù–ï–ù–ò–ï =============
    
    def save_autosave_enabled(self, enabled: bool) -> None:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–∫–ª—é—á–µ–Ω–æ –ª–∏ –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ."""
        self.settings.setValue("autosave/enabled", enabled)
    
    def load_autosave_enabled(self) -> bool:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é True)."""
        return self.settings.value("autosave/enabled", True, type=bool)
    
    def save_autosave_interval(self, minutes: int) -> None:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è (–≤ –º–∏–Ω—É—Ç–∞—Ö)."""
        self.settings.setValue("autosave/interval_minutes", minutes)
    
    def load_autosave_interval(self) -> int:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 5 –º–∏–Ω—É—Ç)."""
        return int(self.settings.value("autosave/interval_minutes", 5))
    
    # ============= –ü–û–°–õ–ï–î–ù–ò–ï –û–¢–ö–†–´–¢–´–ï –§–ê–ô–õ–´ =============
    
    def save_recent_projects(self, project_paths: list) -> None:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤ (–¥–æ 10)."""
        self.settings.beginGroup("recent")
        for i, path in enumerate(project_paths[:10]):
            self.settings.setValue(f"project_{i}", path)
        self.settings.endGroup()
    
    def load_recent_projects(self) -> list:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤."""
        self.settings.beginGroup("recent")
        projects = []
        for i in range(10):
            path = self.settings.value(f"project_{i}")
            if path:
                projects.append(path)
        self.settings.endGroup()
        return projects
    
    def add_recent_project(self, project_path: str) -> None:
        """–î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–µ–∫—Ç –≤ —Å–ø–∏—Å–æ–∫ –Ω–µ–¥–∞–≤–Ω–∏—Ö."""
        recent = self.load_recent_projects()
        if project_path in recent:
            recent.remove(project_path)
        recent.insert(0, project_path)
        self.save_recent_projects(recent)
    
    # ============= –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨–°–ö–ò–ï –°–û–ë–´–¢–ò–Ø =============
    
    def save_custom_events(self, events_data: list) -> None:
        """
        –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Å–æ–±—ã—Ç–∏—è.
        events_data: List[{'name': str, 'color': str, 'shortcut': str, 'description': str}]
        """
        self.settings.beginGroup("custom_events")
        self.settings.remove("")  # –û—á–∏—Å—Ç–∏—Ç—å —Å—Ç–∞—Ä—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        for idx, event_dict in enumerate(events_data):
            event_str = str(event_dict)  # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫ —Å—Ç—Ä–æ–∫—É
            self.settings.setValue(f"event_{idx}", event_str)
        self.settings.endGroup()
    
    def load_custom_events(self) -> list:
        """–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Å–æ–±—ã—Ç–∏—è."""
        import ast
        self.settings.beginGroup("custom_events")
        keys = self.settings.childKeys()
        events = []
        for key in sorted(keys):
            event_str = self.settings.value(key)
            if event_str:
                try:
                    event_dict = ast.literal_eval(event_str)
                    events.append(event_dict)
                except (ValueError, SyntaxError):
                    pass
        self.settings.endGroup()
        return events
    
    # ============= –°–õ–£–ñ–ï–ë–ù–´–ï –ú–ï–¢–û–î–´ =============
    
    def clear_all(self) -> None:
        """–û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏."""
        self.settings.clear()
    
    def sync(self) -> None:
        """–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å —Ö—Ä–∞–Ω–∏–ª–∏—â–µ–º."""
        self.settings.sync()


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä SettingsManager
_settings_manager_instance: Optional[SettingsManager] = None


def get_settings_manager() -> SettingsManager:
    """–ü–æ–ª—É—á–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä SettingsManager."""
    global _settings_manager_instance
    if _settings_manager_instance is None:
        _settings_manager_instance = SettingsManager()
    return _settings_manager_instance


===== shortcut_manager.py =====
"""
ShortcutManager - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω—ã–º–∏ –≥–æ—Ä—è—á–∏–º–∏ –∫–ª–∞–≤–∏—à–∞–º–∏ —á–µ—Ä–µ–∑ QShortcut.
–ü–æ–∑–≤–æ–ª—è–µ—Ç –ø–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–∏—Ç—å –∫–ª–∞–≤–∏—à–∏ –∏ –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∏—Ö –±–µ–∑ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.
"""

from PySide6.QtWidgets import QWidget
from PySide6.QtGui import QKeySequence
from PySide6.QtCore import Qt
from typing import Callable, Dict, List, Optional


class ShortcutManager:
    """
    –ú–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è QShortcut'–∞–º–∏.
    –ü–æ–∑–≤–æ–ª—è–µ—Ç –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞—Ç—å –≥–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏.
    """
    
    def __init__(self, parent: QWidget):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä.
        
        Args:
            parent: –í–∏–¥–∂–µ—Ç, –∫ –∫–æ—Ç–æ—Ä–æ–º—É –ø—Ä–∏–≤—è–∑–∞–Ω—ã shortcuts
        """
        self.parent = parent
        self.shortcuts: Dict[str, tuple] = {}  # {name: (QShortcut, callback)}
    
    def register_shortcut(self, name: str, key: str, callback: Callable) -> None:
        """
        –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–π shortcut.
        
        Args:
            name: –£–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è shortcut'–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'ATTACK', 'PLAY', 'EXPORT')
            key: –ö–ª–∞–≤–∏—à–∞ –∏–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'A', 'Ctrl+S', 'F11')
            callback: –§—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
        """
        # –ï—Å–ª–∏ shortcut —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —É–¥–∞–ª–∏—Ç—å –µ–≥–æ
        self.unregister_shortcut(name)
        
        # –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π shortcut
        from PySide6.QtGui import QShortcut
        shortcut = QShortcut(QKeySequence(key), self.parent)
        shortcut.activated.connect(callback)
        
        self.shortcuts[name] = (shortcut, callback)
    
    def unregister_shortcut(self, name: str) -> None:
        """
        –£–¥–∞–ª–∏—Ç—å shortcut –ø–æ –∏–º–µ–Ω–∏.
        
        Args:
            name: –ò–º—è shortcut'–∞
        """
        if name in self.shortcuts:
            shortcut, _ = self.shortcuts[name]
            shortcut.setEnabled(False)
            del self.shortcuts[name]
    
    def rebind_shortcut(self, name: str, new_key: str) -> None:
        """
        –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å shortcut –Ω–∞ –Ω–æ–≤—É—é –∫–ª–∞–≤–∏—à—É.
        
        Args:
            name: –ò–º—è shortcut'–∞
            new_key: –ù–æ–≤–∞—è –∫–ª–∞–≤–∏—à–∞ –∏–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—è
        """
        if name not in self.shortcuts:
            return
        
        _, callback = self.shortcuts[name]
        self.register_shortcut(name, new_key, callback)
    
    def rebind_multiple(self, hotkeys: Dict[str, str]) -> None:
        """
        –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ shortcut'–æ–≤ —Å—Ä–∞–∑—É.
        
        Args:
            hotkeys: –°–ª–æ–≤–∞—Ä—å {name: key}
                    –ü—Ä–∏–º–µ—Ä: {'ATTACK': 'A', 'DEFENSE': 'D', 'EXPORT': 'Ctrl+E'}
        """
        for name, key in hotkeys.items():
            if name in self.shortcuts:
                self.rebind_shortcut(name, key)
    
    def enable_shortcut(self, name: str) -> None:
        """–í–∫–ª—é—á–∏—Ç—å shortcut."""
        if name in self.shortcuts:
            shortcut, _ = self.shortcuts[name]
            shortcut.setEnabled(True)
    
    def disable_shortcut(self, name: str) -> None:
        """–û—Ç–∫–ª—é—á–∏—Ç—å shortcut."""
        if name in self.shortcuts:
            shortcut, _ = self.shortcuts[name]
            shortcut.setEnabled(False)
    
    def enable_all(self) -> None:
        """–í–∫–ª—é—á–∏—Ç—å –≤—Å–µ shortcuts."""
        for name in self.shortcuts:
            self.enable_shortcut(name)
    
    def disable_all(self) -> None:
        """–û—Ç–∫–ª—é—á–∏—Ç—å –≤—Å–µ shortcuts."""
        for name in self.shortcuts:
            self.disable_shortcut(name)
    
    def get_shortcut_key(self, name: str) -> Optional[str]:
        """
        –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â—É—é –∫–ª–∞–≤–∏—à—É –¥–ª—è shortcut'–∞.
        
        Args:
            name: –ò–º—è shortcut'–∞
            
        Returns:
            –°—Ç—Ä–æ–∫–∞ —Å –∫–ª–∞–≤–∏—à–µ–π –∏–ª–∏ None –µ—Å–ª–∏ not found
        """
        if name not in self.shortcuts:
            return None
        
        shortcut, _ = self.shortcuts[name]
        return shortcut.key().toString()
    
    def list_shortcuts(self) -> Dict[str, str]:
        """
        –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö shortcuts –∏ –∏—Ö –∫–ª–∞–≤–∏—à.
        
        Returns:
            –°–ª–æ–≤–∞—Ä—å {name: key}
        """
        result = {}
        for name, (shortcut, _) in self.shortcuts.items():
            result[name] = shortcut.key().toString()
        return result
    
    def clear_all(self) -> None:
        """–£–¥–∞–ª–∏—Ç—å –≤—Å–µ shortcuts."""
        for name in list(self.shortcuts.keys()):
            self.unregister_shortcut(name)


===== time_utils.py =====
def format_time(seconds: float) -> str:
    mins = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{mins:02d}:{secs:02d}"

===== undo_redo.py =====
# utils/undo_redo.py
# –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è ‚Äî –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –Ω–æ–≤—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É Marker (event_name)

from PySide6.QtCore import QObject
from typing import List
from abc import ABC, abstractmethod


class QUndoCommand(ABC):
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –∫–æ–º–∞–Ω–¥ undo/redo."""

    def __init__(self):
        self.description = ""

    @abstractmethod
    def undo(self):
        """–û—Ç–º–µ–Ω–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é."""
        pass

    @abstractmethod
    def redo(self):
        """–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é."""
        pass


class MarkerCommand(QUndoCommand):
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –∫–æ–º–∞–Ω–¥ –æ–ø–µ—Ä–∞—Ü–∏–π —Å –º–∞—Ä–∫–µ—Ä–∞–º–∏."""

    def __init__(self, markers_list: List):
        super().__init__()
        self.markers = markers_list


class AddMarkerCommand(MarkerCommand):
    """–ö–æ–º–∞–Ω–¥–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –º–∞—Ä–∫–µ—Ä–∞."""

    def __init__(self, markers_list: List, marker):
        super().__init__(markers_list)
        self.marker = marker
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è event_name –≤–º–µ—Å—Ç–æ type.name
        self.description = f"Add {marker.event_name} marker"

    def undo(self):
        """–£–¥–∞–ª–∏—Ç—å –º–∞—Ä–∫–µ—Ä."""
        if self.marker in self.markers:
            self.markers.remove(self.marker)

    def redo(self):
        """–î–æ–±–∞–≤–∏—Ç—å –º–∞—Ä–∫–µ—Ä."""
        if self.marker not in self.markers:
            self.markers.append(self.marker)


class DeleteMarkerCommand(MarkerCommand):
    """–ö–æ–º–∞–Ω–¥–∞ —É–¥–∞–ª–µ–Ω–∏—è –º–∞—Ä–∫–µ—Ä–∞."""

    def __init__(self, markers_list: List, index: int):
        super().__init__(markers_list)
        self.index = index
        if 0 <= index < len(markers_list):
            self.marker = markers_list[index]
            # –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è event_name –≤–º–µ—Å—Ç–æ type.name
            self.description = f"Delete {self.marker.event_name} marker"
        else:
            self.marker = None
            self.description = "Delete marker"

    def undo(self):
        """–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–∞—Ä–∫–µ—Ä."""
        if self.marker and self.marker not in self.markers:
            self.markers.insert(self.index, self.marker)

    def redo(self):
        """–£–¥–∞–ª–∏—Ç—å –º–∞—Ä–∫–µ—Ä."""
        if self.marker and self.marker in self.markers:
            self.markers.remove(self.marker)


class ModifyMarkerCommand(MarkerCommand):
    """–ö–æ–º–∞–Ω–¥–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –º–∞—Ä–∫–µ—Ä–∞."""

    def __init__(self, markers_list: List, index: int, old_marker, new_marker):
        super().__init__(markers_list)
        self.index = index
        self.old_marker = old_marker
        self.new_marker = new_marker
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è event_name –≤–º–µ—Å—Ç–æ type.name
        self.description = f"Modify {old_marker.event_name} marker"

    def undo(self):
        """–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ä—ã–π –º–∞—Ä–∫–µ—Ä."""
        if 0 <= self.index < len(self.markers):
            self.markers[self.index] = self.old_marker

    def redo(self):
        """–ü—Ä–∏–º–µ–Ω–∏—Ç—å –Ω–æ–≤—ã–π –º–∞—Ä–∫–µ—Ä."""
        if 0 <= self.index < len(self.markers):
            self.markers[self.index] = self.new_marker


class ClearMarkersCommand(MarkerCommand):
    """–ö–æ–º–∞–Ω–¥–∞ –æ—á–∏—Å—Ç–∫–∏ –≤—Å–µ—Ö –º–∞—Ä–∫–µ—Ä–æ–≤."""

    def __init__(self, markers_list: List):
        super().__init__(markers_list)
        self.saved_markers = markers_list.copy()
        self.description = "Clear all markers"

    def undo(self):
        """–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Å–µ –º–∞—Ä–∫–µ—Ä—ã."""
        self.markers.clear()
        self.markers.extend(self.saved_markers)

    def redo(self):
        """–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –º–∞—Ä–∫–µ—Ä—ã."""
        self.markers.clear()


class UndoRedoManager(QObject):
    """–ú–µ–Ω–µ–¥–∂–µ—Ä undo/redo –æ–ø–µ—Ä–∞—Ü–∏–π."""

    def __init__(self, max_history: int = 50):
        super().__init__()
        self.history: List[QUndoCommand] = []
        self.current_index = -1
        self.max_history = max_history

    def push_command(self, command: QUndoCommand):
        """–î–æ–±–∞–≤–∏—Ç—å –∫–æ–º–∞–Ω–¥—É –≤ –∏—Å—Ç–æ—Ä–∏—é."""
        # –£–¥–∞–ª–∏—Ç—å –≤—Å–µ –∫–æ–º–∞–Ω–¥—ã –ø–æ—Å–ª–µ —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏ (–µ—Å–ª–∏ –º—ã –¥–µ–ª–∞–ª–∏ undo, –∞ –ø–æ—Ç–æ–º –Ω–æ–≤–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ)
        self.history = self.history[:self.current_index + 1]

        # –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –∫–æ–º–∞–Ω–¥—É
        self.history.append(command)
        self.current_index += 1

        # –û–≥—Ä–∞–Ω–∏—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏
        if len(self.history) > self.max_history:
            self.history.pop(0)
            self.current_index -= 1

    def undo(self):
        """–û—Ç–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –æ–ø–µ—Ä–∞—Ü–∏—é."""
        if self.can_undo():
            command = self.history[self.current_index]
            command.undo()
            self.current_index -= 1

    def redo(self):
        """–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é –æ—Ç–º–µ–Ω—ë–Ω–Ω—É—é –æ–ø–µ—Ä–∞—Ü–∏—é."""
        if self.can_redo():
            self.current_index += 1
            command = self.history[self.current_index]
            command.redo()

    def can_undo(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –º–æ–∂–Ω–æ –ª–∏ –æ—Ç–º–µ–Ω–∏—Ç—å."""
        return self.current_index >= 0

    def can_redo(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –º–æ–∂–Ω–æ –ª–∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å."""
        return self.current_index < len(self.history) - 1

    def clear_history(self):
        """–û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –∫–æ–º–∞–Ω–¥."""
        self.history.clear()
        self.current_index = -1

